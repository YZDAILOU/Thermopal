{"file_contents":{"main.py":{"content":"\nimport eventlet\neventlet.monkey_patch()\n\nimport os\nimport logging\nimport time\nfrom flask import Flask, render_template, request, redirect, url_for, session, jsonify, flash\nfrom flask_socketio import SocketIO, emit, join_room, leave_room\nfrom datetime import datetime, timedelta\nimport pytz\nimport json\nimport random\nimport string\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom models import db, Unit, Battalion, Company, Conduct, User, Session, ActivityLog\n\n# Configure logging for production\nlogging.basicConfig(\n    level=logging.ERROR,  # Only show errors in production\n    format='%(asctime)s - %(levelname)s: %(message)s',\n    handlers=[\n        logging.StreamHandler()\n    ]\n)\n\n# Create Flask app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"dev-secret-key\")\n\n# Configure database with optimizations\ndatabase_url = os.environ.get(\"DATABASE_URL\")\nif not database_url:\n    # Fallback to SQLite for development/deployment without PostgreSQL\n    database_url = \"sqlite:///wbgt_app.db\"\n    print(\"DATABASE_URL not found, using SQLite fallback\")\napp.config[\"SQLALCHEMY_DATABASE_URI\"] = database_url\napp.config[\"SQLALCHEMY_ENGINE_OPTIONS\"] = {\n    \"pool_recycle\": 300,\n    \"pool_pre_ping\": True,\n    \"pool_size\": 10,\n    \"max_overflow\": 20,\n    \"echo\": False  # Disable SQL logging for performance\n}\napp.config[\"SQLALCHEMY_TRACK_MODIFICATIONS\"] = False\n\n# Initialize extensions with production-ready settings\nsocketio = SocketIO(app, async_mode='eventlet', ping_timeout=60, ping_interval=25, \n                    logger=False, engineio_logger=False, cors_allowed_origins=\"*\",\n                    transports=['websocket', 'polling'])\n\n# Initialize database on startup\ndb.init_app(app)\n\n# Initialize database immediately\ndef init_db():\n    with app.app_context():\n        # Create tables if they don't exist (first time setup)\n        try:\n            db.create_all()\n            print(\"Database tables created successfully\")\n        except Exception as e:\n            print(f\"Error creating tables: {e}\")\n        \n        # Safe column addition with proper transaction handling\n        try:\n            # Start fresh transaction\n            db.session.rollback()\n            \n            # Check if most_stringent_zone column exists (PostgreSQL and SQLite compatible)\n            try:\n                db.session.execute(db.text(\"SELECT most_stringent_zone FROM \\\"user\\\" LIMIT 1\"))\n                column_exists = True\n            except Exception:\n                column_exists = False\n            \n            if not column_exists:\n                print(\"Adding missing most_stringent_zone column to user table\")\n                # Use proper PostgreSQL syntax for reserved keyword\n                db.session.execute(db.text('ALTER TABLE \"user\" ADD COLUMN most_stringent_zone VARCHAR(20)'))\n                db.session.commit()\n                print(\"Successfully added most_stringent_zone column\")\n            else:\n                print(\"Database schema is up to date - most_stringent_zone column exists\")\n                \n        except Exception as e:\n            print(f\"Schema check/update error: {e}\")\n            db.session.rollback()\n            # Ensure tables exist even if column addition fails\n            try:\n                db.create_all()\n                print(\"Ensured all tables exist\")\n            except Exception as create_error:\n                print(f\"Error ensuring tables exist: {create_error}\")\n            \n        # One-time migration: Set last_activity_at for existing conducts\n        try:\n            db.session.rollback()  # Start fresh\n            \n            conducts_without_activity = Conduct.query.filter(Conduct.last_activity_at.is_(None)).all()\n            if conducts_without_activity:\n                print(f\"Migrating {len(conducts_without_activity)} conducts to add last_activity_at field\")\n                for conduct in conducts_without_activity:\n                    conduct.last_activity_at = conduct.created_at  # Use creation time as initial activity\n                db.session.commit()\n                print(\"Migration completed successfully\")\n        except Exception as e:\n            print(f\"Migration error: {e}\")\n            db.session.rollback()\n\ninit_db()\n\n# Constants\nSG_TZ = pytz.timezone(\"Asia/Singapore\")\nWBGT_ZONES = {\n    \"white\": {\"work\": 60, \"rest\": 15},\n    \"green\": {\"work\": 45, \"rest\": 15},\n    \"yellow\": {\"work\": 30, \"rest\": 15},\n    \"red\": {\"work\": 30, \"rest\": 30},\n    \"black\": {\"work\": 15, \"rest\": 30},\n    \"test\": {\"work\": 7/60, \"rest\": 10/60},  # 7 seconds work, 10 seconds rest\n    \"cut-off\": {\"work\": 0, \"rest\": 30}\n}\n\n# Zone stringency hierarchy (most stringent = highest index)\nZONE_STRINGENCY = {\n    \"white\": 0,\n    \"green\": 1, \n    \"yellow\": 2,\n    \"red\": 3,\n    \"black\": 4,\n    \"cut-off\": 5,\n    \"test\": 6  # Most stringent for testing purposes\n}\n\n# Global system status for each conduct\nconduct_system_status = {}\n\n# Simple cache for user data to reduce database queries\nuser_cache = {}\nCACHE_TIMEOUT = 30  # seconds\n\n# Background task control\nbackground_task_started = False\n\ndef get_cached_user(user_id):\n    \"\"\"Get user from cache or database\"\"\"\n    current_time = datetime.now().timestamp()\n\n    if user_id in user_cache:\n        cached_data, timestamp = user_cache[user_id]\n        if current_time - timestamp < CACHE_TIMEOUT:\n            return cached_data\n\n    # Cache miss or expired, fetch from database\n    user = User.query.get(user_id)\n    if user:\n        user_cache[user_id] = (user, current_time)\n\n    return user\n\ndef invalidate_user_cache(user_id):\n    \"\"\"Remove user from cache when updated\"\"\"\n    if user_id in user_cache:\n        del user_cache[user_id]\n\ndef get_conduct_system_status(conduct_id):\n    \"\"\"Get system status for a specific conduct\"\"\"\n    if conduct_id not in conduct_system_status:\n        conduct_system_status[conduct_id] = {\n            \"cut_off\": False,\n            \"cut_off_end_time\": None\n        }\n    return conduct_system_status[conduct_id]\n\ndef sg_now():\n    \"\"\"Get current Singapore time as naive datetime\"\"\"\n    now = datetime.now(SG_TZ)\n    # Return naive datetime (without timezone info) in Singapore time\n    return now.replace(tzinfo=None, microsecond=0)\n\ndef get_most_stringent_zone(current_zone, previous_most_stringent):\n    \"\"\"Determine the most stringent zone between current and previous\"\"\"\n    if not previous_most_stringent:\n        return current_zone\n    \n    current_stringency = ZONE_STRINGENCY.get(current_zone, 0)\n    previous_stringency = ZONE_STRINGENCY.get(previous_most_stringent, 0)\n    \n    # Return the more stringent zone (higher index = more stringent)\n    if current_stringency >= previous_stringency:\n        return current_zone\n    else:\n        return previous_most_stringent\n\ndef get_rest_duration_for_most_stringent_zone(most_stringent_zone):\n    \"\"\"Get rest duration based on most stringent zone experienced during cycle\"\"\"\n    if not most_stringent_zone:\n        return 15  # Default to white zone rest\n    return WBGT_ZONES.get(most_stringent_zone, {}).get('rest', 15)\n\ndef emit_user_update(conduct_id, user):\n    \"\"\"Emit user update to all clients in conduct room\"\"\"\n    try:\n        socketio.emit('user_update', {\n            'user': user.name,\n            'status': user.status,\n            'zone': user.zone,\n            'start_time': user.start_time,\n            'end_time': user.end_time,\n            'work_completed': user.work_completed,\n            'pending_rest': user.pending_rest,\n            'role': user.role\n        }, room=f'conduct_{conduct_id}')\n        print(f\"Emitted user update for {user.name} to conduct room {conduct_id}\")\n    except Exception as e:\n        logging.error(f\"Error emitting user update: {e}\")\n\ndef emit_system_status_update(conduct_id, system_status):\n    \"\"\"Emit system status update to all clients in conduct room\"\"\"\n    try:\n        socketio.emit('system_status_update', system_status, room=f'conduct_{conduct_id}')\n        print(f\"Emitted system status update to conduct room {conduct_id}: {system_status}\")\n    except Exception as e:\n        logging.error(f\"Error emitting system status update: {e}\")\n\ndef log_activity(conduct_id, username, action, zone=None, details=None):\n    \"\"\"Log activity for a specific conduct\"\"\"\n    try:\n        # Get current Singapore time\n        singapore_time = sg_now()\n        \n        # Enhanced details based on action type with join/rest times\n        if action == 'user_joined' and not details:\n            details = f\"User joined conduct at {singapore_time.strftime('%I:%M:%S %p')}\"\n        elif action == 'start_rest' and not details:\n            details = f\"Started rest period for {zone} zone at {singapore_time.strftime('%I:%M:%S %p')}\"\n        elif action == 'completed_rest' and not details:\n            details = f\"Completed rest period for {zone} zone at {singapore_time.strftime('%I:%M:%S %p')}\"\n        elif action == 'completed_work' and not details:\n            details = f\"Completed work cycle for {zone} zone at {singapore_time.strftime('%I:%M:%S %p')}\"\n        elif action == 'early_completion' and not details:\n            details = f\"Cycle ended early by user at {singapore_time.strftime('%I:%M:%S %p')}\"\n        elif action == 'interface_reset' and not details:\n            details = f\"Trainer interface reset at {singapore_time.strftime('%I:%M:%S %p')}\"\n\n        print(f\"DEBUG: Creating activity log - conduct_id: {conduct_id}, username: {username}, action: {action}, zone: {zone}, details: {details}\")\n\n        activity = ActivityLog(\n            conduct_id=conduct_id,\n            username=username,\n            action=action,\n            zone=zone,\n            details=details,\n            timestamp=singapore_time\n        )\n        db.session.add(activity)\n        \n        # Flush to ensure the record is written to the database\n        db.session.flush()\n        print(f\"DEBUG: Activity log flushed to database for {username}: {action}\")\n        \n        db.session.commit()\n        print(f\"DEBUG: Activity log committed to database for {username}: {action}\")\n\n        # Emit to conduct room (unlimited history)\n        socketio.emit('history_update', {\n            'history': get_recent_history(conduct_id)\n        }, room=f'conduct_{conduct_id}')\n        print(f\"DEBUG: History update emitted for conduct {conduct_id}\")\n\n    except Exception as e:\n        print(f\"ERROR logging activity: {e}\")\n        logging.error(f\"Error logging activity: {e}\")\n        db.session.rollback()\n\ndef get_recent_history(conduct_id, limit=None):\n    \"\"\"Get activity history for a conduct (unlimited by default)\"\"\"\n    query = ActivityLog.query.filter_by(conduct_id=conduct_id)\\\n                           .order_by(ActivityLog.timestamp.desc())\n    \n    # Only apply limit if specified\n    if limit:\n        query = query.limit(limit)\n    \n    logs = query.all()\n\n    return [{\n        'timestamp': log.timestamp.strftime('%Y-%m-%d %I:%M:%S %p'),\n        'username': log.username,\n        'action': log.action,\n        'zone': log.zone,\n        'details': log.details\n    } for log in logs]\n\ndef show_work_complete_modal(username, zone):\n    \"\"\"Send work complete modal notification to specific user\"\"\"\n    rest_duration = WBGT_ZONES.get(zone, {}).get('rest', 15)\n\n    # Create notification data\n    notification_data = {\n        'username': username,\n        'zone': zone,\n        'rest_duration': rest_duration,\n        'title': 'Work Cycle Complete!',\n        'message': 'Your work cycle has ended. Time to start rest cycle!'\n    }\n\n    # Emit to specific user\n    socketio.emit('show_work_complete_modal', notification_data)\n\n    print(f\"Work complete modal shown for {username} in {zone} zone\")\n    return True\n\ndef check_conduct_activity():\n    \"\"\"Background task to check for conducts that should be deactivated after 24 hours with no users\"\"\"\n    with app.app_context():\n        try:\n            now = sg_now()\n            # Calculate 24 hours ago\n            twenty_four_hours_ago = now - timedelta(hours=24)\n            \n            # Find active conducts with no activity for more than 24 hours\n            old_conducts = Conduct.query.filter(\n                Conduct.status == 'active',\n                Conduct.last_activity_at < twenty_four_hours_ago\n            ).all()\n            \n            for conduct in old_conducts:\n                # Check if any users have ever joined this conduct\n                user_count = User.query.filter_by(conduct_id=conduct.id).count()\n                \n                if user_count == 0:\n                    # No users have joined this conduct in 24 hours - deactivate it\n                    conduct.status = 'inactive'\n                    print(f\"Conduct '{conduct.name}' (PIN: {conduct.pin}) automatically deactivated after 24 hours with no users\")\n                    \n                    # Log the deactivation activity if there's activity logging\n                    try:\n                        log_activity(conduct.id, \"SYSTEM\", 'conduct_deactivated', \n                                   details=f\"Conduct automatically deactivated after 24 hours with no users at {now.strftime('%Y-%m-%d %H:%M:%S')}\")\n                    except:\n                        # If logging fails, continue with deactivation\n                        pass\n            \n            # Commit all changes\n            if old_conducts:\n                db.session.commit()\n                \n        except Exception as e:\n            print(f\"Error in conduct activity check: {e}\")\n            logging.error(f\"Error in conduct activity check: {e}\")\n            db.session.rollback()\n\n# Background task to check for work cycle completions\ndef check_user_cycles():\n    \"\"\"Background task to check for completed work cycles and trigger notifications\"\"\"\n    with app.app_context():  # CRITICAL: Add application context\n        try:\n            now = sg_now()\n            current_time_str = now.strftime('%H:%M:%S')\n\n            # Find users whose work cycles should have ended\n            working_users = User.query.filter_by(status='working').all()\n\n            for user in working_users:\n                if user.end_time:\n                    # Parse end time\n                    end_time_parts = user.end_time.split(':')\n                    end_time = now.replace(\n                        hour=int(end_time_parts[0]),\n                        minute=int(end_time_parts[1]),\n                        second=int(end_time_parts[2]) if len(end_time_parts) > 2 else 0,\n                        microsecond=0\n                    )\n                    \n                    # Handle midnight rollover: if end time is earlier than start time,\n                    # it means the end time is on the next day\n                    if user.start_time:\n                        start_time_parts = user.start_time.split(':')\n                        start_hour = int(start_time_parts[0])\n                        end_hour = int(end_time_parts[0])\n                        \n                        # If end time is significantly earlier than start time, assume next day\n                        if end_hour < start_hour and (start_hour - end_hour) > 12:\n                            end_time = end_time + timedelta(days=1)\n                            if not hasattr(user, '_midnight_logged') or not user._midnight_logged:\n                                print(f\"Server: Midnight rollover detected for working user {user.name}: {user.end_time} moved to next day\")\n                                user._midnight_logged = True\n\n                    # If work cycle has ended\n                    if now >= end_time and not user.work_completed:\n                        print(f\"Work cycle completed for user {user.name} in zone {user.zone}\")\n\n                        # Mark work as completed and pending rest\n                        user.work_completed = True\n                        user.pending_rest = True\n                        user.status = 'idle'  # Change status but keep other data for notification\n\n                        db.session.commit()\n                        invalidate_user_cache(user.id)\n\n                        # Log completion\n                        log_activity(user.conduct_id, user.name, 'completed_work', user.zone, \n                                    f\"Work cycle completed automatically at {current_time_str}\")\n\n                        # Emit user update\n                        emit_user_update(user.conduct_id, user)\n\n                        # Show work complete modal\n                        show_work_complete_modal(user.name, user.zone)\n\n                        # Also emit work cycle completed event for enhanced notification handling\n                        socketio.emit('work_cycle_completed', {\n                            'username': user.name,\n                            'zone': user.zone,\n                            'rest_time': WBGT_ZONES.get(user.zone, {}).get('rest', 15),\n                            'action': 'work_cycle_completed'\n                        }, room=f'conduct_{user.conduct_id}')\n\n                        print(f\"Work completion notification sent for {user.name}\")\n\n            # Check for resting users\n            resting_users = User.query.filter_by(status='resting').all()\n\n            for user in resting_users:\n                if user.end_time:\n                    # Parse end time\n                    end_time_parts = user.end_time.split(':')\n                    end_time = now.replace(\n                        hour=int(end_time_parts[0]),\n                        minute=int(end_time_parts[1]),\n                        second=int(end_time_parts[2]) if len(end_time_parts) > 2 else 0,\n                        microsecond=0\n                    )\n                    \n                    # Handle midnight rollover: if end time is earlier than start time,\n                    # it means the end time is on the next day\n                    if user.start_time:\n                        start_time_parts = user.start_time.split(':')\n                        start_hour = int(start_time_parts[0])\n                        end_hour = int(end_time_parts[0])\n                        \n                        # If end time is significantly earlier than start time, assume next day\n                        if end_hour < start_hour and (start_hour - end_hour) > 12:\n                            end_time = end_time + timedelta(days=1)\n                            print(f\"Server: Midnight rollover detected for resting user {user.name}: {user.end_time} moved to next day\")\n\n                    # Calculate exact time difference\n                    time_diff = (end_time - now).total_seconds()\n                    \n                    # If rest cycle has ended (use exact timing)\n                    if time_diff <= 0:\n                        print(f\"Rest cycle completed for user {user.name} (time diff: {time_diff:.1f}s)\")\n                        print(f\"TIMING DEBUG: Completion - Start: {user.start_time}, End: {user.end_time}, Actual: {now.strftime('%H:%M:%S')}\")\n\n                        # Store zone and conduct info before clearing for logging\n                        completed_zone = user.zone\n                        conduct_id = user.conduct_id\n                        user_name = user.name\n                        \n                        # Use the intended end time for accurate logging (the stored end_time)\n                        intended_end_time = user.end_time  # Use the stored end time string directly\n\n                        # CRITICAL FIX: Log completion BEFORE resetting user data\n                        # This ensures the zone information is available for logging\n                        try:\n                            # RENDER PRODUCTION FIX: Create activity log in separate transaction\n                            activity_log = ActivityLog(\n                                conduct_id=conduct_id,\n                                username=user_name,\n                                action='completed_rest',\n                                zone=completed_zone,\n                                details=f\"Rest cycle completed automatically at {intended_end_time}\",\n                                timestamp=end_time  # Use calculated end_time for precise duration\n                            )\n                            \n                            db.session.add(activity_log)\n                            db.session.flush()  # Flush to get the log ID\n                            print(f\"RENDER DEBUG: Activity log created for {user_name}: completed_rest in {completed_zone}\")\n                            \n                            # Reset user data - ENSURE all flags are cleared\n                            user.status = 'idle'\n                            user.zone = None\n                            user.start_time = None\n                            user.end_time = None\n                            user.work_completed = False\n                            user.pending_rest = False\n                            user.most_stringent_zone = None  # Reset stringent zone tracker\n                            \n                            # Commit BOTH activity log and user changes together\n                            db.session.commit()\n                            print(f\"RENDER DEBUG: Combined database commit successful for {user_name} rest completion\")\n                            \n                            # CRITICAL: Add a small delay to ensure database transaction is fully completed\n                            import time\n                            time.sleep(0.2)  # 200ms delay to ensure database consistency on Render\n                            \n                            # Verify the activity log was actually saved\n                            verification_log = ActivityLog.query.filter_by(\n                                conduct_id=conduct_id,\n                                username=user_name,\n                                action='completed_rest'\n                            ).order_by(ActivityLog.timestamp.desc()).first()\n                            \n                            if verification_log:\n                                print(f\"RENDER DEBUG: Activity log verified in database - ID: {verification_log.id}, Time: {verification_log.timestamp}\")\n                            else:\n                                print(f\"RENDER DEBUG: WARNING - Activity log not found in database after commit\")\n                            \n                        except Exception as combined_error:\n                            print(f\"RENDER DEBUG: Error in combined transaction: {combined_error}\")\n                            db.session.rollback()\n                            \n                            # Fallback: Try logging activity separately\n                            try:\n                                fallback_log = ActivityLog(\n                                    conduct_id=conduct_id,\n                                    username=user_name,\n                                    action='completed_rest',\n                                    zone=completed_zone,\n                                    details=f\"Rest cycle completed automatically at {intended_end_time} (fallback)\",\n                                    timestamp=end_time  # Use intended end time for accuracy\n                                )\n                                db.session.add(fallback_log)\n                                db.session.commit()\n                                print(f\"RENDER DEBUG: Fallback activity log successful for {user_name}\")\n                                \n                                # Now update user separately\n                                user.status = 'idle'\n                                user.zone = None\n                                user.start_time = None\n                                user.end_time = None\n                                user.work_completed = False\n                                user.pending_rest = False\n                                user.most_stringent_zone = None  # Reset stringent zone tracker\n                                db.session.commit()\n                                print(f\"RENDER DEBUG: Fallback user update successful for {user_name}\")\n                                \n                            except Exception as fallback_error:\n                                print(f\"RENDER DEBUG: Fallback also failed: {fallback_error}\")\n                                db.session.rollback()\n\n                        invalidate_user_cache(user.id)\n\n                        # Emit user update\n                        emit_user_update(conduct_id, user)\n\n                        # Emit specific event for zone button re-enabling\n                        socketio.emit('rest_cycle_completed', {\n                            'user': user_name,\n                            'zone': completed_zone,\n                            'action': 'rest_cycle_completed'\n                        }, room=f'conduct_{conduct_id}')\n\n                        # Force immediate history refresh for monitors - ENHANCED VERSION\n                        try:\n                            # Small delay before emitting to ensure database is fully consistent\n                            time.sleep(0.1)\n                            \n                            updated_history = get_recent_history(conduct_id, 20)\n                            \n                            # Emit history update with complete data\n                            socketio.emit('history_update', {\n                                'history': updated_history,\n                                'conduct_id': conduct_id,\n                                'trigger': 'rest_completion'\n                            }, room=f'conduct_{conduct_id}')\n                            print(f\"RENDER DEBUG: History update emitted with {len(updated_history)} entries\")\n                            \n                            # Also emit a global history refresh to ensure all monitors update\n                            socketio.emit('force_history_refresh', {\n                                'conduct_id': conduct_id,\n                                'message': f'{user_name} completed rest cycle in {completed_zone} zone',\n                                'action': 'rest_completed'\n                            }, room=f'conduct_{conduct_id}')\n                            print(f\"RENDER DEBUG: Force history refresh emitted for {user_name}\")\n                            \n                        except Exception as history_error:\n                            print(f\"RENDER DEBUG: Error emitting history update: {history_error}\")\n                            # Fallback: Try again with simpler data\n                            try:\n                                socketio.emit('force_history_refresh', {\n                                    'conduct_id': conduct_id,\n                                    'fallback': True\n                                }, room=f'conduct_{conduct_id}')\n                            except:\n                                pass\n\n                        print(f\"Rest completion processed successfully for {user_name} in zone {completed_zone}\")\n\n        except Exception as e:\n            logging.error(f\"Error in work completion check: {e}\")\n\n# Routes (keeping all existing routes unchanged...)\n\n@app.route('/')\ndef index():\n    \"\"\"Page 1: Home - Conduct Access & Management\"\"\"\n    return render_template('index_new.html')\n\n# New Battalion-Company Structure Routes\n\n@app.route('/create_conduct_new', methods=['GET', 'POST'])\ndef create_conduct_new():\n    if request.method == 'POST':\n        battalion_name = request.form.get('battalion_name', '').strip()\n        company_name = request.form.get('company_name', '').strip()\n        conduct_name = request.form.get('conduct_name', '').strip()\n        company_password = request.form.get('company_password', '').strip()\n\n        if not all([battalion_name, company_name, conduct_name, company_password]):\n            flash('All fields are required.', 'error')\n            return render_template('create_conduct_new.html')\n\n        try:\n            # Check if battalion exists (case insensitive)\n            battalion = Battalion.query.filter(Battalion.name.ilike(battalion_name)).first()\n            if not battalion:\n                # Create new battalion\n                battalion = Battalion(name=battalion_name)\n                battalion.set_password('test123')  # Default password for HQ access\n                db.session.add(battalion)\n                db.session.flush()  # Get battalion ID\n\n            # Check if company exists in this battalion (case insensitive)\n            company = Company.query.filter(\n                Company.battalion_id == battalion.id,\n                Company.name.ilike(company_name)\n            ).first()\n\n            if company:\n                # Verify company password\n                if not company.check_password(company_password):\n                    flash('Incorrect company password.', 'error')\n                    return render_template('create_conduct_new.html')\n            else:\n                # Create new company\n                company = Company(\n                    battalion_id=battalion.id,\n                    name=company_name\n                )\n                company.set_password(company_password)\n                db.session.add(company)\n                db.session.flush()  # Get company ID\n\n            # Create new conduct\n            conduct = Conduct(\n                company_id=company.id,\n                name=conduct_name\n            )\n            conduct.generate_pin()\n            db.session.add(conduct)\n            db.session.commit()\n\n            flash(f'Conduct \"{conduct_name}\" created successfully! PIN: {conduct.pin}', 'success')\n            return redirect(url_for('company_conducts', company_id=company.id))\n\n        except Exception as e:\n            db.session.rollback()\n            flash(f'Error creating conduct: {str(e)}', 'error')\n            return render_template('create_conduct_new.html')\n\n    return render_template('create_conduct_new.html')\n\n@app.route('/view_conducts_new', methods=['GET', 'POST'])\ndef view_conducts_new():\n    if request.method == 'POST':\n        access_type = request.form.get('access_type', '').strip()\n        \n        if access_type == 'battalion':\n            # Battalion HQ access\n            battalion_name = request.form.get('battalion_name', '').strip()\n            battalion_password = request.form.get('battalion_password', '').strip()\n            \n            if not all([battalion_name, battalion_password]):\n                flash('Both battalion name and password are required.', 'error')\n                return render_template('view_conducts_new.html')\n            \n            try:\n                battalion = Battalion.query.filter(Battalion.name.ilike(battalion_name)).first()\n                if battalion and battalion.check_password(battalion_password):\n                    return redirect(url_for('battalion_overview', battalion_id=battalion.id))\n                else:\n                    flash('Invalid battalion name or password.', 'error')\n                    return render_template('view_conducts_new.html')\n                    \n            except Exception as e:\n                flash(f'Error accessing battalion: {str(e)}', 'error')\n                return render_template('view_conducts_new.html')\n                \n        elif access_type == 'company':\n            # Company access with battalion specification\n            company_battalion_name = request.form.get('company_battalion_name', '').strip()\n            company_name = request.form.get('company_name', '').strip()\n            company_password = request.form.get('company_password', '').strip()\n            \n            if not all([company_battalion_name, company_name, company_password]):\n                flash('Battalion name, company name, and company password are all required.', 'error')\n                return render_template('view_conducts_new.html')\n            \n            try:\n                # First find the battalion\n                battalion = Battalion.query.filter(Battalion.name.ilike(company_battalion_name)).first()\n                if not battalion:\n                    flash('Battalion not found. Please check the battalion name.', 'error')\n                    return render_template('view_conducts_new.html')\n                \n                # Then find the company within that battalion\n                company = Company.query.filter(\n                    Company.battalion_id == battalion.id,\n                    Company.name.ilike(company_name)\n                ).first()\n                \n                if company and company.check_password(company_password):\n                    return redirect(url_for('company_conducts', company_id=company.id))\n                else:\n                    flash('Invalid company name or password for the specified battalion.', 'error')\n                    return render_template('view_conducts_new.html')\n                    \n            except Exception as e:\n                flash(f'Error accessing company: {str(e)}', 'error')\n                return render_template('view_conducts_new.html')\n        else:\n            flash('Invalid access type selected.', 'error')\n            return render_template('view_conducts_new.html')\n\n    return render_template('view_conducts_new.html')\n\n@app.route('/battalion_overview/<int:battalion_id>')\ndef battalion_overview(battalion_id):\n    try:\n        battalion = Battalion.query.get_or_404(battalion_id)\n        companies = Company.query.filter_by(battalion_id=battalion_id).order_by(Company.name).all()\n        \n        # Calculate statistics\n        total_conducts = 0\n        active_conducts = 0\n        \n        for company in companies:\n            total_conducts += len(company.conducts)\n            active_conducts += len([c for c in company.conducts if c.status == 'active'])\n\n        return render_template('battalion_overview.html',\n                             battalion=battalion,\n                             company_data=companies,\n                             total_conducts=total_conducts,\n                             active_conducts=active_conducts)\n    except Exception as e:\n        flash(f'Error loading battalion overview: {str(e)}', 'error')\n        return redirect(url_for('index'))\n\n@app.route('/company_conducts/<int:company_id>')\ndef company_conducts(company_id):\n    try:\n        company = Company.query.get_or_404(company_id)\n        conducts = Conduct.query.filter_by(company_id=company_id).order_by(Conduct.created_at.desc()).all()\n        \n        return render_template('company_conducts.html',\n                             company=company,\n                             conducts=conducts)\n    except Exception as e:\n        flash(f'Error loading company conducts: {str(e)}', 'error')\n        return redirect(url_for('index'))\n\n@app.route('/delete_conducts/<int:battalion_id>', methods=['POST'])\ndef delete_conducts(battalion_id):\n    \"\"\"Delete selected conducts - only accessible by battalion accounts\"\"\"\n    try:\n        # Verify battalion access\n        battalion = Battalion.query.get_or_404(battalion_id)\n        \n        # Get list of conduct IDs to delete\n        conduct_ids = request.form.getlist('conduct_ids')\n        if not conduct_ids:\n            flash('No conducts selected for deletion.', 'error')\n            return redirect(url_for('battalion_overview', battalion_id=battalion_id))\n        \n        # Convert to integers and validate\n        try:\n            conduct_ids = [int(cid) for cid in conduct_ids]\n        except ValueError:\n            flash('Invalid conduct IDs provided.', 'error')\n            return redirect(url_for('battalion_overview', battalion_id=battalion_id))\n        \n        # Verify all conducts belong to companies in this battalion\n        conducts_to_delete = []\n        for conduct_id in conduct_ids:\n            conduct = Conduct.query.get(conduct_id)\n            if not conduct:\n                flash(f'Conduct ID {conduct_id} not found.', 'error')\n                return redirect(url_for('battalion_overview', battalion_id=battalion_id))\n            \n            # Check if conduct belongs to a company in this battalion\n            if conduct.company.battalion_id != battalion_id:\n                flash(f'Conduct \"{conduct.name}\" does not belong to this battalion.', 'error')\n                return redirect(url_for('battalion_overview', battalion_id=battalion_id))\n            \n            conducts_to_delete.append(conduct)\n        \n        # Delete associated records first (sessions, users, activity logs)\n        deleted_count = 0\n        for conduct in conducts_to_delete:\n            # Delete sessions first\n            Session.query.filter_by(conduct_id=conduct.id).delete()\n            \n            # Delete activity logs\n            ActivityLog.query.filter_by(conduct_id=conduct.id).delete()\n            \n            # Delete users\n            User.query.filter_by(conduct_id=conduct.id).delete()\n            \n            # Delete the conduct itself\n            db.session.delete(conduct)\n            deleted_count += 1\n        \n        # Commit all deletions\n        db.session.commit()\n        \n        flash(f'Successfully deleted {deleted_count} conduct(s).', 'success')\n        return redirect(url_for('battalion_overview', battalion_id=battalion_id))\n        \n    except Exception as e:\n        db.session.rollback()\n        flash(f'Error deleting conducts: {str(e)}', 'error')\n        return redirect(url_for('battalion_overview', battalion_id=battalion_id))\n\n@app.route('/create_conduct', methods=['GET', 'POST'])\ndef create_conduct():\n    \"\"\"Page 2A: Create Conduct with Authentication\"\"\"\n    if request.method == 'POST':\n        unit_name = request.form.get('unit_name', '').strip()\n        conduct_name = request.form.get('conduct_name', '').strip()\n        unit_password = request.form.get('unit_password', '').strip()\n\n        if not all([unit_name, conduct_name, unit_password]):\n            flash('All fields are required', 'error')\n            return render_template('create_conduct.html')\n\n        try:\n            # Check if unit exists\n            unit = Unit.query.filter_by(name=unit_name).first()\n\n            if unit:\n                # Existing unit - verify password\n                if not unit.check_password(unit_password):\n                    flash('Invalid password for this unit', 'error')\n                    return render_template('create_conduct.html')\n            else:\n                # New unit - create it\n                unit = Unit(name=unit_name)\n                unit.set_password(unit_password)\n                db.session.add(unit)\n                db.session.flush()  # Get the ID\n\n            # Create conduct\n            conduct = Conduct(\n                unit_id=unit.id,\n                name=conduct_name\n            )\n            conduct.generate_pin()\n            db.session.add(conduct)\n            db.session.commit()\n\n            flash(f'Conduct created successfully! PIN: {conduct.pin}', 'success')\n            return redirect(url_for('conduct_list', unit_id=unit.id))\n\n        except Exception as e:\n            db.session.rollback()\n            logging.error(f\"Error creating conduct: {e}\")\n            flash('Error creating conduct', 'error')\n\n    return render_template('create_conduct.html')\n\n@app.route('/view_conducts', methods=['GET', 'POST'])\ndef view_conducts():\n    \"\"\"Page 2B: Authenticate to View Conduct List\"\"\"\n    if request.method == 'POST':\n        unit_name = request.form.get('unit_name', '').strip()\n        unit_password = request.form.get('unit_password', '').strip()\n\n        if not all([unit_name, unit_password]):\n            flash('All fields are required', 'error')\n            return render_template('view_conducts.html')\n\n        unit = Unit.query.filter_by(name=unit_name).first()\n\n        if not unit or not unit.check_password(unit_password):\n            flash('Invalid unit name or password', 'error')\n            return render_template('view_conducts.html')\n\n        return redirect(url_for('conduct_list', unit_id=unit.id))\n\n    return render_template('view_conducts.html')\n\n@app.route('/conduct_list/<int:unit_id>')\ndef conduct_list(unit_id):\n    \"\"\"Page 3: Conduct List Dashboard\"\"\"\n    unit = Unit.query.get_or_404(unit_id)\n    conducts = Conduct.query.filter_by(unit_id=unit_id).order_by(Conduct.created_at.desc()).all()\n\n    return render_template('conduct_list.html', unit=unit, conducts=conducts)\n\n@app.route('/join_conduct', methods=['GET', 'POST'])\ndef join_conduct():\n    \"\"\"Page 4: Conduct Join Verification\"\"\"\n    if request.method == 'POST':\n        pin = request.form.get('pin', '').strip()\n\n        if not pin or len(pin) != 6:\n            flash('Please enter a valid 6-digit PIN', 'error')\n            return render_template('join_conduct.html')\n\n        conduct = Conduct.query.filter_by(pin=pin).first()\n\n        if not conduct:\n            flash('Invalid PIN - conduct not found', 'error')\n            return render_template('join_conduct.html')\n            \n        # If conduct is inactive, reactivate it when someone joins\n        if conduct.status == 'inactive':\n            conduct.status = 'active'\n            conduct.last_activity_at = sg_now()  # Reset the 24-hour timer\n            db.session.commit()\n            print(f\"Conduct '{conduct.name}' (PIN: {conduct.pin}) reactivated by user joining\")\n            \n            # Log the reactivation\n            try:\n                log_activity(conduct.id, \"SYSTEM\", 'conduct_reactivated', \n                           details=f\"Conduct reactivated by user joining at {sg_now().strftime('%Y-%m-%d %H:%M:%S')}\")\n            except:\n                pass\n\n        return redirect(url_for('user_setup', conduct_id=conduct.id))\n\n    return render_template('join_conduct.html')\n\n@app.route('/user_setup/<int:conduct_id>', methods=['GET', 'POST'])\ndef user_setup(conduct_id):\n    \"\"\"Page 5: Identity & Role Selection\"\"\"\n    conduct = Conduct.query.get_or_404(conduct_id)\n    \n    # If conduct is inactive, reactivate it when someone joins\n    if conduct.status == 'inactive':\n        conduct.status = 'active'\n        conduct.last_activity_at = sg_now()  # Reset the 24-hour timer\n        db.session.commit()\n        print(f\"Conduct '{conduct.name}' (PIN: {conduct.pin}) reactivated by user accessing setup\")\n        \n        # Log the reactivation\n        try:\n            log_activity(conduct.id, \"SYSTEM\", 'conduct_reactivated', \n                       details=f\"Conduct reactivated by user accessing setup at {sg_now().strftime('%Y-%m-%d %H:%M:%S')}\")\n        except:\n            pass\n\n    if request.method == 'POST':\n        user_name = request.form.get('user_name', '').strip()\n        role = request.form.get('role', '').strip()\n        conducting_body_password = request.form.get('conducting_body_password', '').strip()\n\n        if not all([user_name, role]):\n            flash('Name and role are required', 'error')\n            return render_template('user_setup.html', conduct=conduct)\n\n        # Validate conducting body password\n        if role == 'conducting_body':\n            if conducting_body_password != 'password':  # Default password\n                flash('Invalid conducting body password', 'error')\n                return render_template('user_setup.html', conduct=conduct)\n\n        try:\n            # Check if user already exists in this conduct\n            existing_user = User.query.filter_by(name=user_name, conduct_id=conduct_id).first()\n\n            if existing_user:\n                # Update existing user\n                existing_user.role = role\n                existing_user.status = 'idle' if role == 'trainer' else 'monitoring'\n                db.session.commit()\n                user = existing_user\n            else:\n                # Create new user\n                user = User(\n                    name=user_name,\n                    role=role,\n                    conduct_id=conduct_id,\n                    status='idle' if role == 'trainer' else 'monitoring'\n                )\n                db.session.add(user)\n                db.session.commit()\n\n            # Update conduct activity when user joins\n            conduct.last_activity_at = sg_now()\n            db.session.commit()\n\n            # Store in session\n            session['user_id'] = user.id\n            session['conduct_id'] = conduct_id\n\n            # Emit user update for real-time monitoring (for trainers only)\n            if role == 'trainer':\n                emit_user_update(conduct_id, user)\n                # Also log the join activity\n                log_activity(conduct_id, user.name, 'user_joined', details=f\"Trainer {user.name} joined the conduct\")\n\n            # Redirect based on role\n            if role == 'trainer':\n                return redirect(url_for('dashboard', user_id=user.id))\n            else:\n                return redirect(url_for('monitor', user_id=user.id))\n\n        except Exception as e:\n            db.session.rollback()\n            logging.error(f\"Error setting up user: {e}\")\n            flash('Error setting up user', 'error')\n\n    return render_template('user_setup.html', conduct=conduct)\n\n@app.route('/dashboard/<int:user_id>')\ndef dashboard(user_id):\n    \"\"\"Page 6: Trainer Interface\"\"\"\n    user = get_cached_user(user_id)\n    if not user:\n        return redirect(url_for('index'))\n\n    if user.role != 'trainer':\n        return redirect(url_for('index'))\n\n    system_status = get_conduct_system_status(user.conduct_id)\n\n    # Only log initial join, not page refreshes\n    # Check if this is a fresh session by looking at recent activity\n    recent_activity = ActivityLog.query.filter_by(\n        conduct_id=user.conduct_id,\n        username=user.name,\n        action='user_joined'\n    ).filter(ActivityLog.timestamp >= sg_now() - timedelta(minutes=5)).first()\n    \n    # Only log if no recent join activity (avoid logging every page refresh)\n    if not recent_activity:\n        log_activity(user.conduct_id, user.name, 'user_joined', details=f\"Trainer accessed dashboard\")\n\n    return render_template('dashboard.html', \n                         user=user, \n                         username=user.name,\n                         zones=WBGT_ZONES,\n                         system_status=system_status)\n\n@app.route('/monitor/<int:user_id>')\ndef monitor(user_id):\n    \"\"\"Page 7: Conducting Body Interface\"\"\"\n    user = get_cached_user(user_id)\n    if not user:\n        return redirect(url_for('index'))\n\n    if user.role != 'conducting_body':\n        return redirect(url_for('index'))\n\n    # Get all users in this conduct\n    users = User.query.filter_by(conduct_id=user.conduct_id).all()\n\n    users_dict = {u.name: {\n        'role': u.role,\n        'status': u.status,\n        'zone': u.zone,\n        'start_time': u.start_time,\n        'end_time': u.end_time,\n        'location': u.location,\n        'work_completed': u.work_completed,\n        'pending_rest': u.pending_rest\n    } for u in users}\n\n    system_status = get_conduct_system_status(user.conduct_id)\n\n    # Only log initial join, not page refreshes\n    # Check if this is a fresh session by looking at recent activity\n    recent_activity = ActivityLog.query.filter_by(\n        conduct_id=user.conduct_id,\n        username=user.name,\n        action='user_joined'\n    ).filter(ActivityLog.timestamp >= sg_now() - timedelta(minutes=5)).first()\n    \n    # Only log if no recent join activity (avoid logging every page refresh)\n    if not recent_activity:\n        log_activity(user.conduct_id, user.name, 'user_joined', details=f\"Conducting body accessed monitor\")\n\n    return render_template('monitor.html',\n                         users=users_dict,\n                         username=user.name,\n                         user_id=user.id,\n                         role=user.role,\n                         conduct_id=user.conduct_id,\n                         zones=WBGT_ZONES,\n                         system_status=system_status,\n                         history=get_recent_history(user.conduct_id, 20))\n\n# API Routes for real-time functionality\n\n@app.route('/set_zone', methods=['POST'])\ndef set_zone():\n    \"\"\"Set WBGT zone for a user\"\"\"\n    user_id = request.form.get('user_id')\n    target_user_name = request.form.get('target_user')\n    zone = request.form.get('zone')\n    location = request.form.get('location')\n\n    # If no target user specified, use current user\n    if not target_user_name:\n        current_user = User.query.get(user_id)\n        if current_user:\n            target_user_name = current_user.name\n\n    try:\n        user = User.query.get(user_id)\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        conduct_id = user.conduct_id\n        system_status = get_conduct_system_status(conduct_id)\n\n        # Check system restrictions\n        if system_status[\"cut_off\"] and user.role != 'conducting_body':\n            return jsonify({\"error\": \"System is in cut-off mode\"}), 403\n\n        # Check mandatory rest period\n        if system_status[\"cut_off_end_time\"]:\n            cut_off_end = datetime.strptime(system_status[\"cut_off_end_time\"], \"%H:%M:%S\")\n            cut_off_end_naive = sg_now().replace(hour=cut_off_end.hour, minute=cut_off_end.minute, second=cut_off_end.second)\n            \n            # Handle midnight rollover for mandatory rest period\n            current_time = sg_now()\n            if cut_off_end.hour < current_time.hour and (current_time.hour - cut_off_end.hour) > 12:\n                cut_off_end_naive = cut_off_end_naive + timedelta(days=1)\n                print(f\"Server: Midnight rollover detected for mandatory rest end time: {system_status['cut_off_end_time']} moved to next day\")\n            \n            if current_time < cut_off_end_naive and user.role != 'conducting_body':\n                return jsonify({\"error\": \"Mandatory rest period is still active\"}), 403\n\n        # Find target user\n        target_user = User.query.filter_by(name=target_user_name, conduct_id=conduct_id).first()\n        if not target_user:\n            return jsonify({\"error\": \"Target user not found\"}), 404\n\n        # Permission check\n        if user.role == 'trainer' and target_user.name != user.name:\n            return jsonify({\"error\": \"Trainers can only set their own zone\"}), 401\n\n        # Prevent zone changes during rest and pending rest states\n        if target_user.status == \"resting\" and user.role != 'conducting_body':\n            return jsonify({\"error\": \"Cannot start work cycle during rest period\"}), 403\n\n        if (target_user.work_completed and target_user.pending_rest) and user.role != 'conducting_body':\n            return jsonify({\"error\": \"Must start rest cycle before beginning new work cycle\"}), 403\n\n        # RENDER DEBUG: Log current user state before zone change\n        print(f\"RENDER DEBUG: Target user {target_user.name} current state - status: {target_user.status}, zone: {target_user.zone}, end_time: {target_user.end_time}, work_completed: {target_user.work_completed}\")\n        \n        # RENDER FIX: Force cache invalidation to ensure fresh data for zone operations\n        invalidate_user_cache(target_user.id)\n\n        # Set zone and timing with WBGT zone overwrite logic\n        now = sg_now()\n        work_duration = WBGT_ZONES.get(zone, {}).get('work', 60)\n        proposed_end = now + timedelta(minutes=work_duration, seconds=0, microseconds=0)\n        print(f\"RENDER DEBUG: New zone {zone} requested, work duration: {work_duration} minutes, proposed end: {proposed_end.strftime('%H:%M:%S')}\")\n\n        # WBGT zone overwrite logic - if user is currently working, use stricter (earlier) end time\n        if target_user.status == 'working' and target_user.end_time and not target_user.work_completed:\n            print(f\"RENDER DEBUG: Zone overwrite triggered for {target_user.name} - current zone: {target_user.zone}, new zone: {zone}\")\n            print(f\"RENDER DEBUG: Current end time: {target_user.end_time}, proposed new end would be: {(now + timedelta(minutes=work_duration)).strftime('%H:%M:%S')}\")\n            \n            current_end_str = target_user.end_time\n            current_end_naive = datetime.strptime(current_end_str, \"%H:%M:%S\")\n            current_end = now.replace(hour=current_end_naive.hour, minute=current_end_naive.minute, second=current_end_naive.second)\n            \n            # Handle midnight rollover: if end time is earlier than start time,\n            # it means the end time is on the next day\n            if target_user.start_time:\n                start_time_parts = target_user.start_time.split(':')\n                start_hour = int(start_time_parts[0])\n                end_hour = current_end_naive.hour\n                \n                # If end time is significantly earlier than start time, assume next day\n                if end_hour < start_hour and (start_hour - end_hour) > 12:\n                    current_end = current_end + timedelta(days=1)\n                    print(f\"RENDER DEBUG: Midnight rollover detected in zone overwrite for {target_user.name}: {current_end_str} moved to next day\")\n            \n            # Only use the earlier time if the current end time is in the future\n            if current_end > now:\n                proposed_end = min(current_end, proposed_end)\n                print(f\"RENDER DEBUG: Zone overwrite applied - using earlier time: {proposed_end.strftime('%H:%M:%S')}\")\n            else:\n                print(f\"RENDER DEBUG: Zone overwrite NOT applied - current end time is in the past: {current_end} vs now: {now}\")\n        else:\n            print(f\"RENDER DEBUG: Zone overwrite NOT triggered for {target_user.name} - status: {target_user.status}, end_time: {target_user.end_time}, work_completed: {target_user.work_completed}\")\n\n        # Strip microseconds for consistent timing across platforms\n        now = now.replace(microsecond=0)\n        proposed_end = proposed_end.replace(microsecond=0)\n\n        # Update user status and track most stringent zone\n        target_user.status = 'working'\n        target_user.zone = zone\n        target_user.start_time = now.strftime('%H:%M:%S')\n        target_user.end_time = proposed_end.strftime('%H:%M:%S')\n        target_user.work_completed = False\n        target_user.pending_rest = False\n        \n        # Track most stringent zone during work cycle\n        target_user.most_stringent_zone = get_most_stringent_zone(zone, target_user.most_stringent_zone)\n        print(f\"STRINGENCY DEBUG: User {target_user.name} - Current zone: {zone}, Most stringent: {target_user.most_stringent_zone}\")\n        \n        if hasattr(target_user, 'location'):\n            target_user.location = location\n\n        db.session.commit()\n\n        # Invalidate cache\n        invalidate_user_cache(target_user.id)\n\n        # Log activity\n        log_activity(conduct_id, target_user.name, 'start_work', zone)\n\n        # Emit updates to conduct room - CRITICAL: This ensures real-time updates\n        emit_user_update(conduct_id, target_user)\n\n        return jsonify({\n            \"success\": True,\n            \"user\": target_user.name,\n            \"zone\": zone,\n            \"start_time\": target_user.start_time,\n            \"end_time\": target_user.end_time\n        })\n\n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error setting zone: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/toggle_cut_off', methods=['POST'])\ndef toggle_cut_off():\n    \"\"\"Toggle cut-off mode for a conduct\"\"\"\n    user_id = request.form.get('user_id')\n\n    try:\n        user = User.query.get(user_id)\n        if not user or user.role != 'conducting_body':\n            return jsonify({\"error\": \"Unauthorized\"}), 401\n\n        conduct_id = user.conduct_id\n        system_status = get_conduct_system_status(conduct_id)\n\n        now = sg_now()\n\n        if system_status[\"cut_off\"]:\n            # Deactivate cut-off, start mandatory rest\n            system_status[\"cut_off\"] = False\n            system_status[\"cut_off_end_time\"] = (now + timedelta(minutes=30)).strftime(\"%H:%M:%S\")\n\n            # Set all trainers to resting\n            trainers = User.query.filter_by(conduct_id=conduct_id, role='trainer').all()\n            for trainer in trainers:\n                trainer.status = 'resting'\n                trainer.zone = None\n                trainer.start_time = now.strftime(\"%H:%M:%S\")\n                trainer.end_time = (now + timedelta(minutes=30)).strftime(\"%H:%M:%S\")\n                # IMPORTANT: Emit individual user updates for each trainer\n                emit_user_update(conduct_id, trainer)\n        else:\n            # Activate cut-off\n            system_status[\"cut_off\"] = True\n            system_status[\"cut_off_end_time\"] = None\n\n            # Set all trainers to idle\n            trainers = User.query.filter_by(conduct_id=conduct_id, role='trainer').all()\n            for trainer in trainers:\n                trainer.status = 'idle'\n                trainer.zone = None\n                trainer.start_time = None\n                trainer.end_time = None\n                # IMPORTANT: Emit individual user updates for each trainer\n                emit_user_update(conduct_id, trainer)\n\n        db.session.commit()\n\n        # CRITICAL: Emit system status update to ALL clients in conduct room\n        emit_system_status_update(conduct_id, system_status)\n\n        return jsonify({\"success\": True, \"system_status\": system_status})\n\n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error toggling cut-off: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/stop_cycle', methods=['POST'])\ndef stop_cycle():\n    \"\"\"Stop current cycle early\"\"\"\n    user_id = request.form.get('user_id')\n\n    try:\n        user = User.query.get(user_id)\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        # Stop current cycle\n        user.status = 'idle'\n        user.zone = None\n        user.start_time = None\n        user.end_time = None\n        user.work_completed = False\n        user.pending_rest = False\n\n        db.session.commit()\n\n        # Invalidate cache\n        invalidate_user_cache(user.id)\n\n        # Log activity\n        log_activity(user.conduct_id, user.name, 'early_completion')\n\n        # CRITICAL: Emit user update to all clients in conduct room\n        emit_user_update(user.conduct_id, user)\n\n        return jsonify({\"success\": True})\n\n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error stopping cycle: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/start_rest', methods=['POST'])\ndef start_rest():\n    \"\"\"Start rest cycle\"\"\"\n    data = request.get_json() if request.is_json else request.form\n    username = data.get('username')\n\n    try:\n        user = User.query.filter_by(name=username).first()\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        # Start rest cycle with precise timing using most stringent zone\n        now = sg_now()\n        \n        # Use most stringent zone for rest duration calculation\n        zone_for_rest = user.most_stringent_zone or user.zone\n        rest_duration = get_rest_duration_for_most_stringent_zone(zone_for_rest)\n        print(f\"STRINGENCY DEBUG: User {user.name} - Current zone: {user.zone}, Most stringent: {user.most_stringent_zone}, Rest duration: {rest_duration} min\")\n\n        # Handle test cycle differently (seconds vs minutes)\n        if user.zone == 'test':\n            end_time = now + timedelta(seconds=rest_duration)\n        else:\n            end_time = now + timedelta(minutes=rest_duration)\n\n        # Store times with exact precision to ensure accurate duration tracking\n        start_time_str = now.strftime('%H:%M:%S')\n        end_time_str = end_time.strftime('%H:%M:%S')\n\n        user.status = 'resting'\n        user.start_time = start_time_str\n        user.end_time = end_time_str\n        \n        # Reset most stringent zone tracker after starting rest\n        user.most_stringent_zone = None\n        \n        print(f\"TIMING DEBUG: Rest start - Now: {now}, End: {end_time}, Duration: {rest_duration}min\")\n        user.work_completed = False\n        user.pending_rest = False\n\n        db.session.commit()\n\n        # Invalidate cache\n        invalidate_user_cache(user.id)\n\n        # Log activity with enhanced details showing stringent zone logic\n        if zone_for_rest == 'test':\n            # Convert minutes to seconds for test zone display (0.1667 min = 10 sec)\n            rest_seconds = int(rest_duration * 60)\n            log_activity(user.conduct_id, user.name, 'start_rest', user.zone, \n                        f\"Started {rest_seconds} second rest period (based on most stringent zone: {zone_for_rest})\")\n        else:\n            # Format minutes properly (remove unnecessary decimals)\n            rest_minutes = int(rest_duration) if rest_duration == int(rest_duration) else rest_duration\n            log_activity(user.conduct_id, user.name, 'start_rest', user.zone, \n                        f\"Started {rest_minutes} minute rest period (based on most stringent zone: {zone_for_rest})\")\n\n        # CRITICAL: Emit user update to all clients in conduct room\n        emit_user_update(user.conduct_id, user)\n\n        return jsonify({\n            \"success\": True,\n            \"start_time\": user.start_time,\n            \"end_time\": user.end_time\n        })\n\n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error starting rest: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/get_user_state/<username>')\ndef get_user_state(username):\n    \"\"\"Get current state of a user\"\"\"\n    try:\n        user = User.query.filter_by(name=username).first()\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        return jsonify({\n            \"status\": user.status,\n            \"zone\": user.zone,\n            \"most_stringent_zone\": user.most_stringent_zone,\n            \"start_time\": user.start_time,\n            \"end_time\": user.end_time,\n            \"work_completed\": user.work_completed,\n            \"pending_rest\": user.pending_rest\n        })\n\n    except Exception as e:\n        logging.error(f\"Error getting user state: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/clear_commands', methods=['POST'])\ndef clear_commands():\n    \"\"\"Clear all commands and reset all trainer interfaces in the conduct\"\"\"\n    user_id = request.form.get('user_id')\n\n    try:\n        user = User.query.get(user_id)\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        if user.role != 'conducting_body':\n            return jsonify({\"error\": \"Only conducting body can use this function\"}), 401\n\n        conduct_id = user.conduct_id\n\n        # Reset all trainers in this conduct to initial idle state\n        trainers = User.query.filter_by(conduct_id=conduct_id, role='trainer').all()\n\n        for trainer in trainers:\n            trainer.status = 'idle'\n            trainer.zone = None\n            trainer.start_time = None\n            trainer.end_time = None\n            trainer.work_completed = False\n            trainer.pending_rest = False\n            trainer.most_stringent_zone = None  # Reset stringent zone tracker\n\n            # Invalidate cache\n            invalidate_user_cache(trainer.id)\n\n            # Log activity\n            log_activity(conduct_id, trainer.name, 'interface_reset', details=\"Trainer interface reset by conducting body\")\n\n            # CRITICAL: Emit user update to all clients in conduct room\n            emit_user_update(conduct_id, trainer)\n\n        # Reset system status\n        system_status = get_conduct_system_status(conduct_id)\n        system_status[\"cut_off\"] = False\n        system_status[\"cut_off_end_time\"] = None\n\n        db.session.commit()\n\n        # Emit system status update\n        emit_system_status_update(conduct_id, system_status)\n\n        # Log conducting body activity\n        log_activity(conduct_id, user.name, 'clear_commands', details=\"All commands cleared and trainer interfaces reset\")\n\n        return jsonify({\"success\": True, \"message\": \"All commands cleared and trainer interfaces reset successfully\"})\n\n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error clearing commands: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/get_server_time')\ndef get_server_time():\n    \"\"\"Get current server time for synchronization\"\"\"\n    # Return UTC timestamp for proper client synchronization\n    return jsonify({\"timestamp\": datetime.utcnow().timestamp()})\n\n@app.route('/get_system_status')\ndef get_system_status():\n    \"\"\"Get current system status\"\"\"\n    # For now return empty status, but in full implementation this would get the actual status\n    return jsonify({\"cut_off\": False, \"cut_off_end_time\": None})\n\n@app.route('/api/debug_rest_completion/<int:conduct_id>')\ndef debug_rest_completion(conduct_id):\n    \"\"\"Debug endpoint to check rest completion status\"\"\"\n    try:\n        # Get all resting users in this conduct\n        resting_users = User.query.filter_by(conduct_id=conduct_id, status='resting').all()\n        \n        now = sg_now()\n        current_time_str = now.strftime('%H:%M:%S')\n        \n        debug_info = {\n            'current_time': current_time_str,\n            'resting_users': [],\n            'activity_logs': []\n        }\n        \n        for user in resting_users:\n            user_info = {\n                'name': user.name,\n                'zone': user.zone,\n                'start_time': user.start_time,\n                'end_time': user.end_time,\n                'should_complete': False\n            }\n            \n            if user.end_time:\n                # Parse end time\n                end_time_parts = user.end_time.split(':')\n                end_time = now.replace(\n                    hour=int(end_time_parts[0]),\n                    minute=int(end_time_parts[1]),\n                    second=int(end_time_parts[2]) if len(end_time_parts) > 2 else 0,\n                    microsecond=0\n                )\n                \n                user_info['should_complete'] = now >= end_time\n                user_info['time_until_completion'] = str(end_time - now) if now < end_time else 'OVERDUE'\n            \n            debug_info['resting_users'].append(user_info)\n        \n        # Get recent activity logs\n        recent_logs = ActivityLog.query.filter_by(conduct_id=conduct_id)\\\n                                     .order_by(ActivityLog.timestamp.desc())\\\n                                     .limit(10).all()\n        \n        debug_info['activity_logs'] = [{\n            'timestamp': log.timestamp.isoformat(),\n            'username': log.username,\n            'action': log.action,\n            'zone': log.zone,\n            'details': log.details\n        } for log in recent_logs]\n        \n        return jsonify(debug_info)\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/check_activity_history/<int:conduct_id>')\ndef check_activity_history(conduct_id):\n    \"\"\"Check recent activity history for debugging\"\"\"\n    try:\n        recent_logs = ActivityLog.query.filter_by(conduct_id=conduct_id)\\\n                                     .order_by(ActivityLog.timestamp.desc())\\\n                                     .all()\n        \n        return jsonify({\n            'conduct_id': conduct_id,\n            'total_logs': len(recent_logs),\n            'recent_activity': [{\n                'id': log.id,\n                'timestamp': log.timestamp.isoformat(),\n                'username': log.username,\n                'action': log.action,\n                'zone': log.zone,\n                'details': log.details\n            } for log in recent_logs]\n        })\n        \n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/force_rest_completion/<username>')\ndef force_rest_completion(username):\n    \"\"\"Force rest completion for testing on Render deployment\"\"\"\n    try:\n        user = User.query.filter_by(name=username).first()\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n            \n        if user.status != 'resting':\n            return jsonify({\"error\": f\"User {username} is not in resting state. Current status: {user.status}\"}), 400\n            \n        now = sg_now()\n        current_time_str = now.strftime('%H:%M:%S')\n        \n        print(f\"FORCE REST COMPLETION: Triggering for {username}\")\n        \n        # Store zone and conduct info before clearing for logging\n        completed_zone = user.zone\n        conduct_id = user.conduct_id\n        user_name = user.name\n        \n        # Log completion BEFORE resetting user data - Enhanced for Render debugging\n        try:\n            # RENDER PRODUCTION FIX: Create activity log directly for better control\n            activity_log = ActivityLog(\n                conduct_id=conduct_id,\n                username=user_name,\n                action='completed_rest',\n                zone=completed_zone,\n                details=f\"Rest cycle completed manually at {current_time_str}\",\n                timestamp=sg_now()\n            )\n            \n            db.session.add(activity_log)\n            db.session.flush()  # Ensure log is created\n            print(f\"FORCE RENDER DEBUG: Activity log created for {user_name}: completed_rest in {completed_zone}\")\n            \n            # Reset user data\n            user.status = 'idle'\n            user.zone = None\n            user.start_time = None\n            user.end_time = None\n            user.work_completed = False\n            user.pending_rest = False\n            \n            # Commit BOTH activity log and user changes together\n            db.session.commit()\n            print(f\"FORCE RENDER DEBUG: Combined database commit successful for {user_name}\")\n            \n        except Exception as combined_error:\n            print(f\"FORCE RENDER DEBUG: Error in combined transaction: {combined_error}\")\n            db.session.rollback()\n            return jsonify({\"error\": f\"Database transaction failed: {combined_error}\"}), 500\n        \n        invalidate_user_cache(user.id)\n        \n        # Emit user update\n        emit_user_update(conduct_id, user)\n        \n        # Emit specific event for zone button re-enabling\n        socketio.emit('rest_cycle_completed', {\n            'user': user_name,\n            'zone': completed_zone,\n            'action': 'rest_cycle_completed'\n        }, room=f'conduct_{conduct_id}')\n        \n        # Force immediate history refresh for monitors\n        socketio.emit('history_update', {\n            'history': get_recent_history(conduct_id, 20)\n        }, room=f'conduct_{conduct_id}')\n        \n        print(f\"FORCE: Rest completion processed successfully for {user_name} in zone {completed_zone}\")\n        \n        return jsonify({\n            \"success\": True,\n            \"message\": f\"Rest completion forced for {username}\",\n            \"previous_zone\": completed_zone,\n            \"new_status\": user.status\n        })\n        \n    except Exception as e:\n        print(f\"FORCE: Error in manual rest completion: {e}\")\n        return jsonify({\"error\": str(e)}), 500\n\n@app.route('/get_conduct_history/<int:conduct_id>')\ndef get_conduct_history(conduct_id):\n    \"\"\"Get activity history for a specific conduct\"\"\"\n    try:\n        history = get_recent_history(conduct_id, 20)\n        return jsonify({\n            'success': True,\n            'conduct_id': conduct_id,\n            'history': history\n        })\n    except Exception as e:\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/test_activity_log/<conduct_id>')\ndef test_activity_log(conduct_id):\n    \"\"\"Test endpoint to verify activity logging works on Render\"\"\"\n    try:\n        conduct_id = int(conduct_id)\n        current_time_str = sg_now().strftime('%H:%M:%S')\n        \n        # Test creating an activity log\n        test_log = ActivityLog(\n            conduct_id=conduct_id,\n            username=\"RENDER_TEST\",\n            action='test_log',\n            zone='test',\n            details=f\"Test activity log created at {current_time_str}\",\n            timestamp=sg_now()\n        )\n        \n        db.session.add(test_log)\n        db.session.commit()\n        \n        # Retrieve recent logs to verify\n        recent_logs = get_recent_history(conduct_id, 5)\n        \n        return jsonify({\n            \"success\": True,\n            \"message\": \"Activity log test successful\",\n            \"test_time\": current_time_str,\n            \"recent_logs\": recent_logs\n        })\n        \n    except Exception as e:\n        print(f\"TEST LOG ERROR: {e}\")\n        return jsonify({\"error\": str(e)}), 500\n\n@app.route('/test_rest_completion/<username>')\ndef test_rest_completion(username):\n    \"\"\"Test endpoint to manually trigger rest completion for debugging\"\"\"\n    try:\n        user = User.query.filter_by(name=username).first()\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n            \n        if user.status != 'resting':\n            return jsonify({\"error\": f\"User {username} is not in resting state. Current status: {user.status}\"}), 400\n            \n        now = sg_now()\n        current_time_str = now.strftime('%H:%M:%S')\n        \n        print(f\"MANUAL TEST: Triggering rest completion for {username}\")\n        print(f\"User status before: {user.status}, zone: {user.zone}, end_time: {user.end_time}\")\n        \n        # Store zone and conduct info before clearing for logging\n        completed_zone = user.zone\n        conduct_id = user.conduct_id\n        user_name = user.name\n        \n        # Log completion BEFORE resetting user data\n        try:\n            log_activity(conduct_id, user_name, 'completed_rest', completed_zone, \n                        f\"Rest cycle completed manually at {current_time_str}\")\n            print(f\"MANUAL TEST: Activity logged for {user_name}: completed_rest in {completed_zone}\")\n        except Exception as log_error:\n            print(f\"MANUAL TEST: Error logging rest completion: {log_error}\")\n        \n        # Reset user data\n        user.status = 'idle'\n        user.zone = None\n        user.start_time = None\n        user.end_time = None\n        user.work_completed = False\n        user.pending_rest = False\n        \n        # Commit database changes\n        try:\n            db.session.commit()\n            print(f\"MANUAL TEST: Database committed for {user_name} rest completion\")\n        except Exception as commit_error:\n            print(f\"MANUAL TEST: Database commit error: {commit_error}\")\n            db.session.rollback()\n            return jsonify({\"error\": f\"Database commit failed: {commit_error}\"}), 500\n        \n        invalidate_user_cache(user.id)\n        \n        # Emit user update\n        emit_user_update(conduct_id, user)\n        \n        # Emit specific event for zone button re-enabling\n        socketio.emit('rest_cycle_completed', {\n            'user': user_name,\n            'zone': completed_zone,\n            'action': 'rest_cycle_completed'\n        }, room=f'conduct_{conduct_id}')\n        \n        # Force immediate history refresh for monitors\n        socketio.emit('history_update', {\n            'history': get_recent_history(conduct_id, 20)\n        }, room=f'conduct_{conduct_id}')\n        \n        print(f\"MANUAL TEST: Rest completion processed successfully for {user_name} in zone {completed_zone}\")\n        \n        return jsonify({\n            \"success\": True,\n            \"message\": f\"Rest completion triggered for {username}\",\n            \"previous_zone\": completed_zone,\n            \"new_status\": user.status\n        })\n        \n    except Exception as e:\n        print(f\"MANUAL TEST: Error in manual rest completion: {e}\")\n        return jsonify({\"error\": str(e)}), 500\n\n@app.route('/remove_user', methods=['POST'])\ndef remove_user():\n    \"\"\"Remove a user from the conduct\"\"\"\n    user_id = request.form.get('user_id')\n    target_user_name = request.form.get('target_user')\n\n    try:\n        user = User.query.get(user_id)\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        if user.role != 'conducting_body':\n            return jsonify({\"error\": \"Only conducting body can remove users\"}), 401\n\n        conduct_id = user.conduct_id\n\n        # Find target user\n        target_user = User.query.filter_by(name=target_user_name, conduct_id=conduct_id).first()\n        if not target_user:\n            return jsonify({\"error\": \"Target user not found\"}), 404\n\n        if target_user.role == 'conducting_body':\n            return jsonify({\"error\": \"Cannot remove conducting body users\"}), 403\n\n        # Log removal activity\n        log_activity(conduct_id, user.name, 'user_removed', details=f\"Removed user {target_user_name} from conduct\")\n\n        # Remove the user from the database\n        db.session.delete(target_user)\n        db.session.commit()\n\n        # Invalidate cache\n        invalidate_user_cache(target_user.id)\n\n        # Emit user removal update to all clients in conduct room\n        socketio.emit('user_removed', {\n            'user': target_user_name\n        }, room=f'conduct_{conduct_id}')\n\n        return jsonify({\"success\": True, \"message\": f\"User {target_user_name} removed successfully\"})\n\n    except Exception as e:\n        db.session.rollback()\n        logging.error(f\"Error removing user: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n@app.route('/force_work_completion_check/<username>')\ndef force_work_completion_check(username):\n    \"\"\"Manually trigger work completion check for a user\"\"\"\n    try:\n        user = User.query.filter_by(name=username).first()\n        if not user:\n            return jsonify({\"error\": \"User not found\"}), 404\n\n        if user.work_completed and user.pending_rest and user.zone:\n            # Show work complete modal\n            show_work_complete_modal(user.name, user.zone)\n            \n            # Emit work cycle completed event\n            socketio.emit('work_cycle_completed', {\n                'username': user.name,\n                'zone': user.zone,\n                'rest_time': WBGT_ZONES.get(user.zone, {}).get('rest', 15),\n                'action': 'work_cycle_completed'\n            }, room=f'conduct_{user.conduct_id}')\n            \n            return jsonify({\"success\": True, \"message\": \"Work completion notification sent\"})\n        else:\n            return jsonify({\"success\": False, \"message\": \"No pending work completion found\"})\n\n    except Exception as e:\n        logging.error(f\"Error in force work completion check: {e}\")\n        return jsonify({\"error\": \"Internal server error\"}), 500\n\n# Socket.IO events\n\n@socketio.on('connect')\ndef handle_connect():\n    \"\"\"Handle client connection\"\"\"\n    print(f'Client connected: {request.sid}')\n    # Start background task when first client connects\n    global background_task_started\n    if not background_task_started:\n        start_background_tasks()\n        background_task_started = True\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    \"\"\"Handle client disconnection\"\"\"\n    print(f'Client disconnected: {request.sid}')\n\n@socketio.on('join_conduct')\ndef handle_join_conduct(data):\n    \"\"\"Join a conduct room for real-time updates\"\"\"\n    conduct_id = data.get('conduct_id')\n    if conduct_id:\n        join_room(f'conduct_{conduct_id}')\n        print(f'Client {request.sid} joined conduct room: {conduct_id}')\n\n        # Send current system status immediately when joining\n        system_status = get_conduct_system_status(conduct_id)\n        emit('system_status_update', system_status)\n\n@socketio.on('leave_conduct')\ndef handle_leave_conduct(data):\n    \"\"\"Leave a conduct room\"\"\"\n    conduct_id = data.get('conduct_id')\n    if conduct_id:\n        leave_room(f'conduct_{conduct_id}')\n        print(f'Client {request.sid} left conduct room: {conduct_id}')\n\n@app.route('/change_password', methods=['GET', 'POST'])\ndef change_password():\n    \"\"\"Change password for battalion or company\"\"\"\n    if request.method == 'POST':\n        password_type = request.form.get('password_type')\n        \n        if password_type == 'battalion':\n            battalion_name = request.form.get('battalion_name', '').strip()\n            current_password = request.form.get('current_password', '').strip()\n            new_password = request.form.get('new_password', '').strip()\n            confirm_password = request.form.get('confirm_password', '').strip()\n            \n            # Validation\n            if not all([battalion_name, current_password, new_password, confirm_password]):\n                flash('All fields are required.', 'error')\n                return render_template('change_password.html')\n            \n            if new_password != confirm_password:\n                flash('New passwords do not match.', 'error')\n                return render_template('change_password.html')\n            \n            if len(new_password) < 6:\n                flash('Password must be at least 6 characters long.', 'error')\n                return render_template('change_password.html')\n            \n            # Find battalion (case sensitive)\n            battalion = Battalion.query.filter_by(name=battalion_name).first()\n            if not battalion:\n                flash('Battalion not found.', 'error')\n                return render_template('change_password.html')\n            \n            # Verify current password\n            if not battalion.check_password(current_password):\n                flash('Current password is incorrect.', 'error')\n                return render_template('change_password.html')\n            \n            # Update password\n            battalion.set_password(new_password)\n            db.session.commit()\n            \n            flash(f'Battalion password for {battalion.name.title()} updated successfully!', 'success')\n            return render_template('change_password.html')\n            \n        elif password_type == 'company':\n            battalion_name = request.form.get('company_battalion_name', '').strip()\n            company_name = request.form.get('company_name', '').strip()\n            current_password = request.form.get('company_current_password', '').strip()\n            new_password = request.form.get('company_new_password', '').strip()\n            confirm_password = request.form.get('company_confirm_password', '').strip()\n            \n            # Validation\n            if not all([battalion_name, company_name, current_password, new_password, confirm_password]):\n                flash('All fields are required.', 'error')\n                return render_template('change_password.html')\n            \n            if new_password != confirm_password:\n                flash('New passwords do not match.', 'error')\n                return render_template('change_password.html')\n            \n            if len(new_password) < 6:\n                flash('Password must be at least 6 characters long.', 'error')\n                return render_template('change_password.html')\n            \n            # Find battalion first (case sensitive)\n            battalion = Battalion.query.filter_by(name=battalion_name).first()\n            if not battalion:\n                flash('Battalion not found.', 'error')\n                return render_template('change_password.html')\n            \n            # Find company within the battalion (case sensitive)\n            company = Company.query.filter_by(\n                name=company_name, \n                battalion_id=battalion.id\n            ).first()\n            if not company:\n                flash(f'Company {company_name} not found in {battalion_name} Battalion.', 'error')\n                return render_template('change_password.html')\n            \n            # Verify current password\n            if not company.check_password(current_password):\n                flash('Current password is incorrect.', 'error')\n                return render_template('change_password.html')\n            \n            # Update password\n            company.set_password(new_password)\n            db.session.commit()\n            \n            flash(f'Company password for {company.name.title()} Company updated successfully!', 'success')\n            return render_template('change_password.html')\n    \n    return render_template('change_password.html')\n\n# Schedule work completion checks every 5 seconds\ndef start_background_tasks():\n    \"\"\"Start background tasks\"\"\"\n    def run_checks():\n        conduct_check_counter = 0\n        while True:\n            eventlet.sleep(1)  # Check every 1 second for responsive completion detection\n            check_user_cycles()\n            \n            # Check conduct activity every 60 seconds (1 minute)\n            conduct_check_counter += 1\n            if conduct_check_counter >= 60:\n                check_conduct_activity()\n                conduct_check_counter = 0\n\n    eventlet.spawn(run_checks)\n    print(\"Background task started for work cycle monitoring (1-second intervals) and conduct activity checking (1-minute intervals)\")\n\n# Add cleanup handler\n@app.teardown_appcontext\ndef cleanup_db(error):\n    \"\"\"Clean up database connections\"\"\"\n    if error:\n        db.session.rollback()\n    db.session.remove()\n\n# Expose app for WSGI deployment (like gunicorn)\nif __name__ == '__main__':\n    # Start background tasks\n    start_background_tasks()\n    background_task_started = True\n\n    # Use SocketIO's built-in server instead of Gunicorn for better WebSocket support\n    socketio.run(app, host='0.0.0.0', port=5000, debug=False, use_reloader=False, \n                 allow_unsafe_werkzeug=True, log_output=False)\nelse:\n    # For deployment with gunicorn, start background tasks\n    start_background_tasks()\n    background_task_started = True\n","size_bytes":85996},"models.py":{"content":"from flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom datetime import datetime\nimport random\nimport string\n\nclass Base(DeclarativeBase):\n    pass\n\ndb = SQLAlchemy(model_class=Base)\n\nclass Battalion(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(200), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    # Relationship\n    companies = db.relationship('Company', backref='battalion', lazy=True, cascade='all, delete-orphan')\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\n    def __repr__(self):\n        return f'<Battalion {self.name}>'\n\nclass Company(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    battalion_id = db.Column(db.Integer, db.ForeignKey('battalion.id'), nullable=False)\n    name = db.Column(db.String(200), nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    # Unique constraint on battalion_id and name combination\n    __table_args__ = (db.UniqueConstraint('battalion_id', 'name', name='_battalion_company_uc'),)\n\n    # Relationship\n    conducts = db.relationship('Conduct', backref='company', lazy=True, cascade='all, delete-orphan')\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\n    def __repr__(self):\n        return f'<Company {self.name}>'\n\n# Keep Unit model for backward compatibility but mark as deprecated\nclass Unit(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(200), unique=True, nullable=False)\n    password_hash = db.Column(db.String(256), nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    # Relationship - keeping for backward compatibility\n    conducts_legacy = db.relationship('Conduct', foreign_keys='Conduct.unit_id', backref='unit', lazy=True)\n\n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n\n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n\n    def __repr__(self):\n        return f'<Unit {self.name}>'\n\nclass Conduct(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    company_id = db.Column(db.Integer, db.ForeignKey('company.id'), nullable=False)\n    unit_id = db.Column(db.Integer, db.ForeignKey('unit.id'), nullable=True)  # Keep for backward compatibility\n    name = db.Column(db.String(200), nullable=False)\n    pin = db.Column(db.String(6), unique=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_activity_at = db.Column(db.DateTime, default=datetime.utcnow)  # For 24-hour deactivation logic\n    status = db.Column(db.String(20), default='active')  # active, inactive\n\n    # Relationship\n    users = db.relationship('User', backref='conduct', lazy=True, cascade='all, delete-orphan')\n    sessions = db.relationship('Session', backref='conduct', lazy=True, cascade='all, delete-orphan')\n\n    def generate_pin(self):\n        \"\"\"Generate a unique 6-digit PIN\"\"\"\n        while True:\n            pin = ''.join(random.choices(string.digits, k=6))\n            if not Conduct.query.filter_by(pin=pin).first():\n                self.pin = pin\n                break\n\n    def __repr__(self):\n        return f'<Conduct {self.name}>'\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(100), nullable=False)\n    role = db.Column(db.String(20), nullable=False)  # trainer, conducting_body\n    conduct_id = db.Column(db.Integer, db.ForeignKey('conduct.id'), nullable=False)\n    joined_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    # Current session data (for active users)\n    status = db.Column(db.String(20), default='idle')  # idle, working, resting\n    zone = db.Column(db.String(20))\n    start_time = db.Column(db.String(10))\n    end_time = db.Column(db.String(10))\n    location = db.Column(db.String(200))\n    work_completed = db.Column(db.Boolean, default=False)\n    pending_rest = db.Column(db.Boolean, default=False)\n    most_stringent_zone = db.Column(db.String(20))  # Track harshest zone during current cycle\n\n    # Relationship\n    sessions = db.relationship('Session', backref='user', lazy=True, cascade='all, delete-orphan')\n\n    def __repr__(self):\n        return f'<User {self.name}>'\n\nclass Session(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    conduct_id = db.Column(db.Integer, db.ForeignKey('conduct.id'), nullable=False)\n    zone = db.Column(db.String(20))\n    start_time = db.Column(db.DateTime)\n    end_time = db.Column(db.DateTime)\n    status = db.Column(db.String(20))  # completed, interrupted, ongoing\n    session_type = db.Column(db.String(20))  # work, rest\n    location = db.Column(db.String(200))\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n\n    def __repr__(self):\n        return f'<Session {self.user.name} - {self.zone}>'\n\nclass ActivityLog(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    conduct_id = db.Column(db.Integer, db.ForeignKey('conduct.id'), nullable=False)\n    username = db.Column(db.String(100), nullable=False)\n    action = db.Column(db.String(50), nullable=False)\n    zone = db.Column(db.String(20))\n    details = db.Column(db.Text)\n    timestamp = db.Column(db.DateTime, nullable=False)  # Remove default, will be set explicitly\n\n    def __repr__(self):\n        return f'<ActivityLog {self.username} - {self.action}>'","size_bytes":6036},"replit.md":{"content":"# WBGT Training Conduct Management System (ThermoPal)\n\n## Project Overview\nThis is a comprehensive Flask-based web application for managing training conducts with WBGT (Wet Bulb Globe Temperature) monitoring capabilities. The system helps military/training units organize and monitor training sessions with proper heat stress management and most stringent zone safety logic.\n\n## Program Understanding (August 8, 2025)\n**ThermoPal** is a sophisticated real-time training management system that:\n- Manages military/training conducts with unique 6-digit PINs\n- Implements WBGT heat zone safety protocols (WHITE, GREEN, YELLOW, RED, BLACK, TEST, CUT-OFF)\n- Uses \"most stringent zone\" logic - rest time based on harshest conditions worked during cycle\n- Provides real-time Socket.IO communication between trainers and participants\n- Features comprehensive multi-platform notification system for work/rest cycle management\n\n## Static Folder File Purposes\n\n### Core Application Files\n- **main.js**: Central JavaScript controller managing Socket.IO, server time sync, work completion modals, and dashboard updates\n- **icon-192.png**: Application icon for notifications, PWA manifest, and browser branding\n\n### Multi-Layered Notification System\nThe application implements a redundant notification strategy ensuring compatibility across all browsers and devices:\n\n#### Primary Notification Layer\n- **enhanced-notifications.js**: Universal notification manager with background monitoring and service worker integration\n- **sw.js**: Main service worker for background task management, caching, and notification handling\n\n#### Browser-Specific Layers\n- **chrome-notifications.js**: Chrome-specific push notifications with permission management and action buttons\n- **chrome-sw.js**: Chrome service worker for notification clicks and progressive reminder system\n- **firefox-notifications.js**: Firefox-specific notification handling (if present)\n\n#### Firebase Integration\n- **firebase-notifications.js**: Firebase Cloud Messaging for cross-platform push notifications with mobile optimization\n- **firebase-messaging-sw.js**: Firebase background message handling with action button integration\n\n#### Production & Fallback Systems\n- **production-notifications.js**: Production-optimized system with 5-second refresh cycles for Chrome on Render\n- **work-notifications.js**: Work cycle completion management with progressive reminders and mobile vibration\n- **simple-refresh-notifications.js**: Manual refresh-based system for iOS Safari and restrictive browsers\n\n## Recent Changes\n- **August 8, 2025**: Program analysis completed - identified comprehensive WBGT training management system\n  - **ARCHITECTURE**: Multi-layered notification system with 8 different notification strategies\n  - **SAFETY CRITICAL**: \"Most stringent zone\" logic ensures proper rest based on harshest conditions worked\n  - **REAL-TIME**: Socket.IO integration for instant communication between all participants\n  - **CROSS-PLATFORM**: Firebase integration with mobile optimization and progressive web app features\n  - **PRODUCTION READY**: Multiple fallback systems ensure notifications work in all deployment environments\n\n## Core Features\n\n### Conduct Management\n- **Creation**: Companies can create training conducts with unique 6-digit PINs\n- **Joining**: Users join conducts and are tracked in real-time\n- **Status Tracking**: Active/inactive conduct management with 24-hour auto-deactivation\n- **Real-time Updates**: Socket.IO for instant status synchronization\n\n### WBGT Zone Management\n- **Zone Types**: WHITE (60min work/15min rest) → GREEN (45/15) → YELLOW (30/15) → RED (30/30) → BLACK (15/30) → TEST (7sec/10sec) → CUT-OFF (0/30)\n- **Most Stringent Logic**: Rest duration based on harshest zone worked during current cycle\n- **Zone Hierarchy**: WHITE(0) < GREEN(1) < YELLOW(2) < RED(3) < BLACK(4) < CUT-OFF(5) < TEST(6)\n- **Safety Critical**: Automatic tracking prevents heat-related injuries\n\n### Database Models\n- **Battalion**: Top-level military unit\n- **Company**: Sub-unit within battalion\n- **Conduct**: Individual training session\n- **User**: Participants in conducts (includes `most_stringent_zone` field for safety tracking)\n- **Session**: User session tracking\n- **ActivityLog**: Comprehensive audit trail\n\n### Frontend (Jinja2 Templates)\n- **Responsive design**: TailwindCSS for modern UI\n- **Real-time updates**: JavaScript with Socket.IO client\n- **Status indicators**: Visual feedback for conduct and user states\n- **Mobile optimized**: Progressive Web App features with offline capability\n\n### Notification Architecture\n- **Multi-browser support**: Chrome, Firefox, Safari compatibility\n- **Background processing**: Service workers for notifications when app is closed\n- **Progressive reminders**: Escalating alert system for missed notifications\n- **Mobile features**: Vibration, audio alerts, and push notification integration\n- **Production deployment**: Render platform optimization with multiple fallback systems\n\n## User Preferences\n- Technical communication style preferred for system analysis\n- Comprehensive documentation of all system components\n- Focus on safety-critical aspects of WBGT monitoring","size_bytes":5209},"static/chrome-notifications.js":{"content":"// Chrome-compatible push notifications system\nclass ChromeNotificationManager {\n    constructor() {\n        // Enhanced Chrome detection\n        this.isChrome = this.detectChrome();\n        this.isSupported = 'Notification' in window && 'serviceWorker' in navigator;\n        this.registration = null;\n        this.currentUser = null;\n        console.log('Chrome detected:', this.isChrome, 'Notifications supported:', this.isSupported);\n    }\n\n    detectChrome() {\n        // More reliable Chrome detection\n        const isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n        const isEdge = /Edg/.test(navigator.userAgent);\n        return isChrome && !isEdge;\n    }\n\n    async initialize(username) {\n        this.currentUser = username;\n        console.log('Initializing Chrome notification manager for:', username);\n\n        if (!this.isSupported) {\n            console.log('Push notifications not supported in this browser');\n            return false;\n        }\n\n        if (!this.isChrome) {\n            console.log('Not Chrome browser, skipping Chrome-specific initialization');\n            return false;\n        }\n\n        try {\n            // Check if service worker already exists\n            const existingRegistration = await navigator.serviceWorker.getRegistration('/');\n            if (existingRegistration) {\n                console.log('Using existing service worker registration');\n                this.registration = existingRegistration;\n            } else {\n                // Register service worker for Chrome\n                this.registration = await navigator.serviceWorker.register('/static/chrome-sw.js', {\n                    scope: '/'\n                });\n                console.log('Chrome service worker registered:', this.registration);\n            }\n\n            await navigator.serviceWorker.ready;\n            \n            // Check current permission status\n            console.log('Current notification permission:', Notification.permission);\n            \n            if (Notification.permission === 'granted') {\n                console.log('Chrome notifications already granted');\n                return true;\n            } else if (Notification.permission === 'denied') {\n                console.log('Chrome notifications permanently denied');\n                return false;\n            } else {\n                console.log('Chrome notifications need permission - user interaction required');\n                return false; // Return false so UI can show permission button\n            }\n\n        } catch (error) {\n            console.error('Error initializing Chrome notifications:', error);\n            return false;\n        }\n    }\n\n    async requestPermission() {\n        if (!('Notification' in window)) {\n            console.log('Notification API not available');\n            return 'denied';\n        }\n\n        console.log('Current permission status:', Notification.permission);\n\n        if (Notification.permission === 'granted') {\n            return 'granted';\n        }\n\n        if (Notification.permission === 'denied') {\n            console.log('Notifications permanently denied by user');\n            return 'denied';\n        }\n\n        try {\n            // For Chrome, we need to request permission with user interaction\n            console.log('Requesting notification permission...');\n            const permission = await Notification.requestPermission();\n            console.log('Permission result:', permission);\n            return permission;\n        } catch (error) {\n            console.error('Error requesting notification permission:', error);\n            return 'denied';\n        }\n    }\n\n    // Show work completion notification for Chrome\n    showWorkCompleteNotification(data) {\n        console.log('Attempting to show Chrome work completion notification:', data);\n        console.log('Notification permission:', Notification.permission);\n        console.log('Service worker registration:', this.registration);\n\n        if (!this.isSupported) {\n            console.log('Notifications not supported in this browser');\n            return false;\n        }\n\n        if (Notification.permission !== 'granted') {\n            console.log('Notification permission not granted. Current status:', Notification.permission);\n            return false;\n        }\n\n        const title = data.title || 'Work Cycle Complete!';\n        const body = data.message || `Your ${data.zone?.toUpperCase() || 'WORK'} zone work cycle has ended. Time to start your rest cycle!`;\n\n        const options = {\n            body: body,\n            icon: '/static/icon-192.png',\n            badge: '/static/icon-192.png',\n            tag: 'wbgt-work-complete-' + Date.now(), // Unique tag to prevent duplicates\n            requireInteraction: true,\n            silent: false,\n            vibrate: [800, 300, 800, 300, 800],\n            timestamp: Date.now(),\n            actions: [\n                {\n                    action: 'start-rest',\n                    title: 'Start Rest',\n                    icon: '/static/icon-192.png'\n                },\n                {\n                    action: 'dismiss',\n                    title: 'Dismiss',\n                    icon: '/static/icon-192.png'\n                }\n            ],\n            data: {\n                username: data.username || this.currentUser,\n                zone: data.zone,\n                rest_duration: data.rest_duration,\n                url: '/dashboard',\n                type: 'work_complete'\n            }\n        };\n\n        try {\n            // Prefer service worker notifications for better control\n            if (this.registration && this.registration.showNotification) {\n                console.log('Showing notification via service worker');\n                this.registration.showNotification(title, options)\n                    .then(() => {\n                        console.log('Chrome service worker notification shown successfully');\n                    })\n                    .catch(error => {\n                        console.error('Service worker notification failed:', error);\n                        this.fallbackToDirectNotification(title, options);\n                    });\n            } else {\n                console.log('Service worker not available, using direct notification');\n                this.fallbackToDirectNotification(title, options);\n            }\n\n            // Add Chrome-specific vibration\n            if ('vibrate' in navigator) {\n                navigator.vibrate([800, 300, 800, 300, 800]);\n            }\n\n            console.log('Chrome notification request completed');\n            return true;\n\n        } catch (error) {\n            console.error('Error showing Chrome notification:', error);\n            return false;\n        }\n    }\n\n    // Fallback to direct browser notification\n    fallbackToDirectNotification(title, options) {\n        try {\n            console.log('Creating direct browser notification');\n            const notification = new Notification(title, options);\n            \n            notification.onclick = () => {\n                console.log('Direct notification clicked');\n                window.focus();\n                notification.close();\n                this.handleNotificationClick('default', options.data);\n            };\n\n            notification.onshow = () => {\n                console.log('Direct notification shown');\n            };\n\n            notification.onerror = (error) => {\n                console.error('Direct notification error:', error);\n            };\n\n        } catch (error) {\n            console.error('Failed to create direct notification:', error);\n        }\n    }\n\n    // Handle notification click actions\n    handleNotificationClick(action, data) {\n        console.log('Chrome notification clicked:', action, data);\n\n        switch (action) {\n            case 'start-rest':\n                this.startRestCycle(data.username);\n                break;\n            case 'dismiss':\n                this.dismissNotification(data);\n                break;\n            default:\n                window.focus();\n                break;\n        }\n    }\n\n    // Start rest cycle from notification\n    async startRestCycle(username) {\n        try {\n            const response = await fetch('/start_rest', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: new URLSearchParams({\n                    username: username\n                })\n            });\n\n            const data = await response.json();\n            if (data.success) {\n                console.log('Rest cycle started successfully from Chrome notification');\n                // Update dashboard if function exists\n                if (typeof window.updateDashboard === 'function') {\n                    window.updateDashboard();\n                }\n            } else {\n                console.error('Failed to start rest cycle:', data.error);\n            }\n        } catch (error) {\n            console.error('Error starting rest cycle from Chrome notification:', error);\n        }\n    }\n\n    // Dismiss notification and start reminder system\n    dismissNotification(data) {\n        console.log('Chrome notification dismissed:', data);\n        \n        // Send message to service worker for reminder system\n        if (navigator.serviceWorker.controller) {\n            navigator.serviceWorker.controller.postMessage({\n                type: 'notification-dismissed',\n                username: data.username,\n                zone: data.zone,\n                rest_duration: data.rest_duration\n            });\n        }\n\n        // Start progressive reminders\n        this.startProgressiveReminders(data);\n    }\n\n    // Progressive reminder system for Chrome\n    startProgressiveReminders(data) {\n        console.log('Starting Chrome progressive reminders');\n\n        // Store reminder state\n        const reminderState = {\n            username: data.username,\n            zone: data.zone,\n            rest_duration: data.rest_duration,\n            dismissedAt: Date.now(),\n            reminderCount: 0\n        };\n\n        localStorage.setItem('chromeReminderState', JSON.stringify(reminderState));\n\n        // First reminder after 5 seconds\n        setTimeout(() => {\n            this.showProgressiveReminder(reminderState);\n            \n            // Then every 10 seconds\n            const reminderInterval = setInterval(() => {\n                const currentState = JSON.parse(localStorage.getItem('chromeReminderState') || '{}');\n                if (currentState.username === data.username) {\n                    this.showProgressiveReminder(currentState);\n                } else {\n                    clearInterval(reminderInterval);\n                }\n            }, 10000);\n            \n        }, 5000);\n    }\n\n    // Show progressive reminder\n    showProgressiveReminder(state) {\n        state.reminderCount = (state.reminderCount || 0) + 1;\n        localStorage.setItem('chromeReminderState', JSON.stringify(state));\n\n        console.log(`Showing Chrome progressive reminder #${state.reminderCount}`);\n\n        const title = `Reminder #${state.reminderCount}: Start Your Rest!`;\n        const body = `You dismissed this ${state.reminderCount} time(s). You need to start your rest cycle.`;\n\n        const options = {\n            body: body,\n            icon: '/static/icon-192.png',\n            badge: '/static/icon-192.png',\n            tag: `wbgt-reminder-${Date.now()}`,\n            requireInteraction: true,\n            silent: false,\n            vibrate: [500, 200, 500, 200, 500],\n            timestamp: Date.now(),\n            actions: [\n                {\n                    action: 'start-rest',\n                    title: 'Start Rest Now',\n                    icon: '/static/icon-192.png'\n                },\n                {\n                    action: 'dismiss',\n                    title: 'Dismiss Again',\n                    icon: '/static/icon-192.png'\n                }\n            ],\n            data: {\n                username: state.username,\n                zone: state.zone,\n                rest_duration: state.rest_duration,\n                isReminder: true,\n                reminderCount: state.reminderCount\n            }\n        };\n\n        if (this.registration && this.registration.showNotification) {\n            this.registration.showNotification(title, options);\n        } else {\n            new Notification(title, options);\n        }\n\n        // Enhanced vibration for reminders\n        if ('vibrate' in navigator) {\n            navigator.vibrate([500, 200, 500, 200, 500]);\n        }\n    }\n\n    // Clear all reminders\n    clearReminders() {\n        console.log('Clearing Chrome notification reminders');\n        localStorage.removeItem('chromeReminderState');\n        \n        // Send message to service worker\n        if (navigator.serviceWorker.controller) {\n            navigator.serviceWorker.controller.postMessage({\n                type: 'clear-reminders'\n            });\n        }\n    }\n\n    // Check for pending reminders on page load\n    checkPendingReminders() {\n        const reminderState = localStorage.getItem('chromeReminderState');\n        if (reminderState) {\n            try {\n                const state = JSON.parse(reminderState);\n                if (state.username === this.currentUser) {\n                    console.log('Resuming Chrome reminders from previous session');\n                    \n                    // Resume reminders immediately\n                    this.showProgressiveReminder(state);\n                    \n                    const reminderInterval = setInterval(() => {\n                        const currentState = JSON.parse(localStorage.getItem('chromeReminderState') || '{}');\n                        if (currentState.username === this.currentUser) {\n                            this.showProgressiveReminder(currentState);\n                        } else {\n                            clearInterval(reminderInterval);\n                        }\n                    }, 10000);\n                }\n            } catch (error) {\n                console.error('Error resuming Chrome reminders:', error);\n                localStorage.removeItem('chromeReminderState');\n            }\n        }\n    }\n}\n\n// Global Chrome notification manager\nlet chromeNotificationManager = null;\n\n// Initialize Chrome notifications\nasync function initializeChromeNotifications(username) {\n    if (!chromeNotificationManager) {\n        chromeNotificationManager = new ChromeNotificationManager();\n    }\n    return await chromeNotificationManager.initialize(username);\n}\n\n// Request Chrome notification permission (must be called from user interaction)\nasync function requestChromeNotificationPermission() {\n    console.log('Requesting Chrome notification permission with user interaction');\n    \n    if (!chromeNotificationManager) {\n        chromeNotificationManager = new ChromeNotificationManager();\n    }\n    \n    const permission = await chromeNotificationManager.requestPermission();\n    console.log('Permission request result:', permission);\n    \n    if (permission === 'granted') {\n        // Try to register service worker again\n        try {\n            const registration = await navigator.serviceWorker.register('/static/chrome-sw.js', {\n                scope: '/'\n            });\n            chromeNotificationManager.registration = registration;\n            await navigator.serviceWorker.ready;\n            console.log('Service worker registered after permission granted');\n            return true;\n        } catch (error) {\n            console.error('Failed to register service worker after permission:', error);\n            return false;\n        }\n    }\n    \n    return permission === 'granted';\n}\n\n// Test Chrome notification (for debugging)\nfunction testChromeNotification() {\n    console.log('Testing Chrome notification manually');\n    \n    if (!chromeNotificationManager) {\n        console.error('Chrome notification manager not initialized');\n        return;\n    }\n    \n    const testData = {\n        title: 'Test Notification',\n        message: 'This is a test notification to verify Chrome notifications are working.',\n        username: window.currentUser || 'TestUser',\n        zone: 'test',\n        rest_duration: 10\n    };\n    \n    const result = chromeNotificationManager.showWorkCompleteNotification(testData);\n    console.log('Test notification result:', result);\n    return result;\n}\n\n// Show work complete notification for Chrome\nfunction showChromeWorkCompleteNotification(data) {\n    if (chromeNotificationManager) {\n        chromeNotificationManager.showWorkCompleteNotification(data);\n    }\n}\n\n// Clear Chrome reminders\nfunction clearChromeReminders() {\n    if (chromeNotificationManager) {\n        chromeNotificationManager.clearReminders();\n    }\n}\n\n// Check pending Chrome reminders\nfunction checkPendingChromeReminders() {\n    if (chromeNotificationManager) {\n        chromeNotificationManager.checkPendingReminders();\n    }\n}","size_bytes":17125},"static/chrome-sw.js":{"content":"// Chrome Service Worker for Push Notifications\nconst CACHE_NAME = 'wbgt-chrome-notifications-v1';\n\n// Handle notification clicks\nself.addEventListener('notificationclick', function(event) {\n    console.log('Chrome notification clicked:', event.notification.tag, event.action);\n\n    const notificationData = event.notification.data || {};\n    \n    event.notification.close();\n\n    if (event.action === 'start-rest') {\n        // Handle start rest action\n        event.waitUntil(\n            clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {\n                // Try to find existing dashboard window\n                for (const client of clientList) {\n                    if (client.url.includes('/dashboard') && 'focus' in client) {\n                        console.log('Focusing existing dashboard window from Chrome SW');\n                        client.postMessage({\n                            type: 'notification-action',\n                            action: 'start-rest',\n                            username: notificationData.username\n                        });\n                        return client.focus();\n                    }\n                }\n                \n                // Open new window if no existing one found\n                console.log('Opening new dashboard window from Chrome SW');\n                if (clients.openWindow) {\n                    return clients.openWindow('/dashboard').then(client => {\n                        if (client) {\n                            client.postMessage({\n                                type: 'notification-action',\n                                action: 'start-rest',\n                                username: notificationData.username\n                            });\n                        }\n                    });\n                }\n            })\n        );\n    } else if (event.action === 'dismiss') {\n        // Handle dismiss action - start reminder system\n        console.log('Chrome notification dismissed via action button');\n        \n        // Store reminder state and start progressive reminders\n        event.waitUntil(\n            startChromeReminderSystem(notificationData)\n        );\n    } else {\n        // Default action - open dashboard\n        event.waitUntil(\n            clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {\n                for (const client of clientList) {\n                    if (client.url.includes('/dashboard') && 'focus' in client) {\n                        return client.focus();\n                    }\n                }\n                if (clients.openWindow) {\n                    return clients.openWindow('/dashboard');\n                }\n            })\n        );\n    }\n});\n\n// Handle notification close (when user swipes away)\nself.addEventListener('notificationclose', function(event) {\n    console.log('Chrome notification closed/swiped away:', event.notification.tag);\n    \n    const notificationData = event.notification.data || {};\n    \n    // Only start reminders if this is a work completion notification (not a reminder)\n    if (!notificationData.isReminder && notificationData.type === 'work_complete') {\n        console.log('Starting Chrome reminders after notification close');\n        event.waitUntil(\n            startChromeReminderSystem(notificationData)\n        );\n    }\n});\n\n// Chrome reminder system variables\nlet chromeReminderInterval = null;\nlet chromeFirstReminderTimeout = null;\n\n// Start Chrome reminder system\nfunction startChromeReminderSystem(data) {\n    console.log('Starting Chrome reminder system for:', data.username);\n    \n    // Clear any existing reminders\n    clearChromeReminderSystem();\n    \n    // Start first reminder after 5 seconds\n    chromeFirstReminderTimeout = setTimeout(() => {\n        console.log('Chrome first reminder after 5 seconds');\n        showChromeReminder(data);\n        \n        // Then continuous reminders every 10 seconds\n        chromeReminderInterval = setInterval(() => {\n            console.log('Chrome continuous reminder (10 second interval)');\n            showChromeReminder(data);\n        }, 10000);\n        \n    }, 5000);\n    \n    return Promise.resolve();\n}\n\n// Clear Chrome reminder system\nfunction clearChromeReminderSystem() {\n    if (chromeReminderInterval) {\n        clearInterval(chromeReminderInterval);\n        chromeReminderInterval = null;\n    }\n    if (chromeFirstReminderTimeout) {\n        clearTimeout(chromeFirstReminderTimeout);\n        chromeFirstReminderTimeout = null;\n    }\n}\n\n// Show Chrome reminder notification\nfunction showChromeReminder(data) {\n    const reminderTitle = \"Rest Cycle Reminder!\";\n    const reminderBody = `${data.username}, you still need to start your ${data.rest_duration} ${data.zone === 'test' ? 'second' : 'minute'} rest cycle after completing ${data.zone?.toUpperCase() || 'WORK'} zone work.`;\n\n    const reminderOptions = {\n        body: reminderBody,\n        icon: '/static/icon-192.png',\n        badge: '/static/icon-192.png',\n        tag: 'wbgt-chrome-reminder-' + Date.now(),\n        requireInteraction: true,\n        vibrate: [500, 200, 500, 200, 500],\n        silent: false,\n        renotify: true,\n        timestamp: Date.now(),\n        actions: [\n            {\n                action: 'start-rest',\n                title: 'Start Rest Now',\n                icon: '/static/icon-192.png'\n            },\n            {\n                action: 'dismiss',\n                title: 'Dismiss',\n                icon: '/static/icon-192.png'\n            }\n        ],\n        data: {\n            username: data.username,\n            zone: data.zone,\n            rest_duration: data.rest_duration,\n            isReminder: true,\n            url: '/dashboard'\n        }\n    };\n\n    console.log('Showing Chrome reminder notification');\n    return self.registration.showNotification(reminderTitle, reminderOptions);\n}\n\n// Handle messages from main thread\nself.addEventListener('message', function(event) {\n    if (event.data && event.data.type === 'clear-reminders') {\n        console.log('Clearing Chrome reminders via message');\n        clearChromeReminderSystem();\n    } else if (event.data && event.data.type === 'notification-dismissed') {\n        console.log('Chrome notification dismissed via message');\n        const { username, zone, rest_duration } = event.data;\n        startChromeReminderSystem({ username, zone, rest_duration });\n    }\n});\n\n// Install and activate service worker\nself.addEventListener('install', function(event) {\n    console.log('Chrome Service Worker installing...');\n    self.skipWaiting();\n});\n\nself.addEventListener('activate', function(event) {\n    console.log('Chrome Service Worker activating...');\n    event.waitUntil(self.clients.claim());\n});","size_bytes":6769},"static/enhanced-notifications.js":{"content":"// Enhanced Universal WBGT Notification System\n// Works for all zones and persists across page navigation\n// Supports background notifications via Service Worker\n\nclass EnhancedNotificationManager {\n    constructor() {\n        this.username = null;\n        this.serviceWorker = null;\n        this.isSupported = 'serviceWorker' in navigator && 'Notification' in window;\n        this.lastCheckTime = 0;\n        this.pageVisibilityInitialized = false;\n        this.currentUserState = null;\n        \n        console.log('[Notifications] Enhanced notification manager initialized');\n        console.log('[Notifications] Service Worker supported:', 'serviceWorker' in navigator);\n        console.log('[Notifications] Notifications supported:', 'Notification' in window);\n    }\n\n    // Initialize the notification system\n    async initialize(username) {\n        this.username = username;\n        console.log('[Notifications] Initializing enhanced notifications for:', username);\n\n        if (!this.isSupported) {\n            console.warn('[Notifications] Enhanced notifications not supported');\n            return false;\n        }\n\n        try {\n            // Register service worker\n            await this.registerServiceWorker();\n            \n            // Request notification permission\n            await this.requestPermission();\n            \n            // Set up page visibility API\n            this.setupPageVisibilityAPI();\n            \n            // Set up service worker messaging\n            this.setupServiceWorkerMessaging();\n            \n            // Start monitoring\n            await this.startMonitoring();\n            \n            // Perform immediate check for missed notifications\n            await this.checkForMissedNotifications();\n            \n            console.log('[Notifications] Enhanced notification system fully initialized');\n            return true;\n            \n        } catch (error) {\n            console.error('[Notifications] Failed to initialize enhanced notifications:', error);\n            return false;\n        }\n    }\n\n    // Register service worker\n    async registerServiceWorker() {\n        try {\n            const registration = await navigator.serviceWorker.register('/static/sw.js', {\n                scope: '/'\n            });\n            \n            console.log('[Notifications] Service worker registered:', registration);\n            \n            // Wait for service worker to be ready\n            await navigator.serviceWorker.ready;\n            this.serviceWorker = registration;\n            \n            return registration;\n            \n        } catch (error) {\n            console.error('[Notifications] Service worker registration failed:', error);\n            throw error;\n        }\n    }\n\n    // Request notification permission\n    async requestPermission() {\n        if (Notification.permission === 'granted') {\n            console.log('[Notifications] Permission already granted');\n            return true;\n        }\n\n        if (Notification.permission === 'denied') {\n            console.warn('[Notifications] Notification permission denied');\n            return false;\n        }\n\n        try {\n            const permission = await Notification.requestPermission();\n            const granted = permission === 'granted';\n            \n            console.log('[Notifications] Permission request result:', permission);\n            return granted;\n            \n        } catch (error) {\n            console.error('[Notifications] Permission request failed:', error);\n            return false;\n        }\n    }\n\n    // Set up page visibility API for better notification handling\n    setupPageVisibilityAPI() {\n        if (this.pageVisibilityInitialized) {\n            return;\n        }\n\n        // Handle page visibility changes\n        document.addEventListener('visibilitychange', () => {\n            if (!document.hidden) {\n                console.log('[Notifications] Page became visible - checking for missed notifications');\n                this.checkForMissedNotifications(false);\n            } else {\n                console.log('[Notifications] Page became hidden - background monitoring active');\n            }\n        });\n\n        // Handle page focus/blur\n        window.addEventListener('focus', () => {\n            console.log('[Notifications] Window focused - checking for missed notifications');\n            this.checkForMissedNotifications(false);\n        });\n\n        // Handle page load/unload\n        window.addEventListener('load', () => {\n            console.log('[Notifications] Page loaded - checking for missed notifications');\n            setTimeout(() => this.checkForMissedNotifications(false), 1000);\n        });\n\n        window.addEventListener('beforeunload', () => {\n            console.log('[Notifications] Page unloading - ensuring background monitoring');\n        });\n\n        this.pageVisibilityInitialized = true;\n        console.log('[Notifications] Page visibility API initialized');\n    }\n\n    // Set up service worker messaging\n    setupServiceWorkerMessaging() {\n        if (!navigator.serviceWorker) {\n            return;\n        }\n\n        navigator.serviceWorker.addEventListener('message', (event) => {\n            console.log('[Notifications] Message from service worker:', event.data);\n            \n            const { type, data } = event.data;\n            \n            switch (type) {\n                case 'WORK_COMPLETION_DETECTED':\n                    this.handleWorkCompletionFromSW(data);\n                    break;\n                case 'START_REST_FROM_NOTIFICATION':\n                    this.handleStartRestFromNotification(data);\n                    break;\n            }\n        });\n\n        console.log('[Notifications] Service worker messaging initialized');\n    }\n\n    // Start monitoring via service worker\n    async startMonitoring() {\n        if (!this.serviceWorker || !this.username) {\n            console.warn('[Notifications] Cannot start monitoring - missing service worker or username');\n            return;\n        }\n\n        try {\n            // Send message to service worker to start monitoring\n            await this.sendMessageToSW('START_MONITORING', { username: this.username });\n            console.log('[Notifications] Started background monitoring for:', this.username);\n            \n        } catch (error) {\n            console.error('[Notifications] Failed to start monitoring:', error);\n        }\n    }\n\n    // Stop monitoring\n    async stopMonitoring() {\n        if (!this.serviceWorker || !this.username) {\n            return;\n        }\n\n        try {\n            await this.sendMessageToSW('STOP_MONITORING', { username: this.username });\n            console.log('[Notifications] Stopped background monitoring for:', this.username);\n            \n        } catch (error) {\n            console.error('[Notifications] Failed to stop monitoring:', error);\n        }\n    }\n\n    // Send message to service worker\n    async sendMessageToSW(type, data) {\n        if (!navigator.serviceWorker.controller) {\n            console.warn('[Notifications] No service worker controller available');\n            return;\n        }\n\n        navigator.serviceWorker.controller.postMessage({\n            type: type,\n            data: data\n        });\n    }\n\n    // Check for missed notifications (called when page becomes visible)\n    async checkForMissedNotifications(showNoNotificationMessage = false) {\n        if (!this.username) {\n            return;\n        }\n\n        try {\n            console.log('[Notifications] Checking for missed notifications...');\n            \n            const response = await fetch(`/get_user_state/${this.username}`);\n            const userData = await response.json();\n            \n            console.log('[Notifications] Current user state:', userData);\n            \n            // Check if there's a pending work completion\n            if (userData.work_completed && userData.pending_rest && userData.zone) {\n                console.log('[Notifications] Found missed work completion - showing notification');\n                await this.showImmediateNotification(userData);\n                return true; // Found notifications\n            } else {\n                console.log('[Notifications] No missed notifications found');\n                if (showNoNotificationMessage) {\n                    this.showNoNotificationMessage();\n                }\n                return false; // No notifications found\n            }\n            \n            this.currentUserState = userData;\n            \n        } catch (error) {\n            console.error('[Notifications] Error checking for missed notifications:', error);\n            if (showNoNotificationMessage) {\n                alert('Error checking for notifications. Please try again.');\n            }\n            return false;\n        }\n    }\n\n    // Show message when no notifications are found (for manual refresh)\n    showNoNotificationMessage() {\n        // Create or update no notification message\n        let modal = document.getElementById('no-notification-modal');\n        if (!modal) {\n            modal = this.createNoNotificationModal();\n        }\n\n        // Show modal\n        modal.classList.remove('hidden');\n        modal.style.display = 'flex';\n\n        // Auto-hide after 3 seconds\n        setTimeout(() => {\n            modal.classList.add('hidden');\n            modal.style.display = 'none';\n        }, 3000);\n\n        console.log('[Notifications] No notification message shown');\n    }\n\n    // Create no notification modal\n    createNoNotificationModal() {\n        const modalHTML = `\n            <div id=\"no-notification-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden\">\n                <div class=\"bg-white rounded-lg p-6 max-w-md mx-4 shadow-xl border-2 border-green-500\">\n                    <div class=\"text-center\">\n                        <div class=\"text-4xl mb-4\">✅</div>\n                        <h3 class=\"text-xl font-bold text-green-600 mb-4\">All Clear!</h3>\n                        <p class=\"text-gray-700 mb-4\">No work completion notifications at this time.</p>\n                        <button onclick=\"document.getElementById('no-notification-modal').classList.add('hidden'); document.getElementById('no-notification-modal').style.display = 'none';\" \n                            class=\"bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition-all duration-200\">\n                            OK\n                        </button>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        document.body.insertAdjacentHTML('beforeend', modalHTML);\n        return document.getElementById('no-notification-modal');\n    }\n\n    // Show immediate notification for missed work completion\n    async showImmediateNotification(userData) {\n        const restTime = this.getRestTimeForZone(userData.zone);\n        const timeUnit = userData.zone === 'test' ? 'second' : 'minute';\n        \n        console.log('[Notifications] Showing immediate notification for zone:', userData.zone);\n        \n        // Show browser notification if supported\n        if (Notification.permission === 'granted') {\n            try {\n                const notification = new Notification(`🚨 Work Complete - ${userData.zone.toUpperCase()} Zone`, {\n                    body: `Your ${userData.zone.toUpperCase()} work cycle has ended. Start your ${restTime} ${timeUnit} rest cycle now!`,\n                    icon: '/static/icon-192.png',\n                    tag: `missed-work-complete-${userData.zone}`,\n                    requireInteraction: true,\n                    vibrate: [200, 100, 200, 100, 200]\n                });\n\n                notification.onclick = () => {\n                    window.focus();\n                    notification.close();\n                    this.focusRestButton(userData.zone);\n                };\n\n                console.log('[Notifications] Browser notification shown for missed completion');\n                \n            } catch (error) {\n                console.error('[Notifications] Failed to show browser notification:', error);\n            }\n        }\n        \n        // Show modal notification\n        this.showModalNotification(userData, restTime, timeUnit);\n        \n        // Play audio alert\n        this.playAudioAlert();\n        \n        // Trigger vibration if supported\n        this.triggerVibration();\n        \n        // Focus rest button or show UI indicator\n        this.focusRestButton(userData.zone);\n    }\n\n    // Handle work completion detected by service worker\n    handleWorkCompletionFromSW(data) {\n        console.log('[Notifications] Work completion detected by service worker:', data);\n        \n        // Show modal and visual indicators even if page is active\n        this.showModalNotification({\n            zone: data.zone,\n            work_completed: true,\n            pending_rest: true\n        }, data.restTime, data.timeUnit);\n        \n        this.playAudioAlert();\n        this.triggerVibration();\n        this.focusRestButton(data.zone);\n    }\n\n    // Handle start rest from notification click\n    handleStartRestFromNotification(data) {\n        console.log('[Notifications] Starting rest from notification click:', data);\n        \n        // Trigger rest start if possible\n        if (typeof window.startRest === 'function') {\n            window.startRest(data.zone);\n        } else {\n            // Focus the rest button for the zone\n            this.focusRestButton(data.zone);\n        }\n    }\n\n    // Show modal notification\n    showModalNotification(userData, restTime, timeUnit) {\n        // Create or update modal\n        let modal = document.getElementById('enhanced-notification-modal');\n        if (!modal) {\n            modal = this.createNotificationModal();\n        }\n\n        // Update modal content\n        document.getElementById('enhanced-modal-title').textContent = `🚨 Work Complete - ${userData.zone.toUpperCase()} Zone`;\n        document.getElementById('enhanced-modal-message').textContent = \n            `Your ${userData.zone.toUpperCase()} work cycle has ended. You must start your ${restTime} ${timeUnit} rest cycle now!`;\n\n        // Show modal\n        modal.classList.remove('hidden');\n        modal.style.display = 'flex';\n\n        // Set up event listeners\n        this.setupModalEventListeners(userData);\n\n        console.log('[Notifications] Modal notification shown for zone:', userData.zone);\n    }\n\n    // Create notification modal\n    createNotificationModal() {\n        const modalHTML = `\n            <div id=\"enhanced-notification-modal\" class=\"fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 hidden\">\n                <div class=\"bg-white rounded-lg p-6 max-w-md mx-4 shadow-2xl border-4 border-red-500 animate-pulse\">\n                    <div class=\"text-center\">\n                        <div class=\"text-4xl mb-4\">🚨</div>\n                        <h3 id=\"enhanced-modal-title\" class=\"text-xl font-bold text-red-600 mb-4\"></h3>\n                        <p id=\"enhanced-modal-message\" class=\"text-gray-700 mb-6 font-medium\"></p>\n                        <div class=\"flex flex-col gap-3\">\n                            <button id=\"enhanced-start-rest\" class=\"bg-green-600 text-white px-6 py-3 rounded-lg font-bold hover:bg-green-700 transition-all duration-200 shadow-lg\">\n                                Start Rest Cycle\n                            </button>\n                            <button id=\"enhanced-dismiss\" class=\"bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700 transition-all duration-200\">\n                                Dismiss\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        document.body.insertAdjacentHTML('beforeend', modalHTML);\n        return document.getElementById('enhanced-notification-modal');\n    }\n\n    // Set up modal event listeners\n    setupModalEventListeners(userData) {\n        const startButton = document.getElementById('enhanced-start-rest');\n        const dismissButton = document.getElementById('enhanced-dismiss');\n        const modal = document.getElementById('enhanced-notification-modal');\n\n        // Remove existing listeners\n        const newStartButton = startButton.cloneNode(true);\n        const newDismissButton = dismissButton.cloneNode(true);\n        startButton.parentNode.replaceChild(newStartButton, startButton);\n        dismissButton.parentNode.replaceChild(newDismissButton, dismissButton);\n\n        // Add new listeners\n        newStartButton.addEventListener('click', () => {\n            modal.classList.add('hidden');\n            modal.style.display = 'none';\n            \n            // Try to start rest automatically\n            if (typeof window.startRest === 'function') {\n                window.startRest(userData.zone);\n            } else {\n                this.focusRestButton(userData.zone);\n            }\n            \n            this.markAsNotified();\n        });\n\n        newDismissButton.addEventListener('click', () => {\n            modal.classList.add('hidden');\n            modal.style.display = 'none';\n            this.markAsNotified();\n        });\n\n        // Close on outside click\n        modal.addEventListener('click', (e) => {\n            if (e.target === modal) {\n                modal.classList.add('hidden');\n                modal.style.display = 'none';\n                this.markAsNotified();\n            }\n        });\n    }\n\n    // Focus rest button for the specific zone\n    focusRestButton(zone) {\n        // Try to find and focus the rest button\n        const restButton = document.querySelector(`button[onclick*=\"startRest('${zone}')\"]`) ||\n                          document.querySelector(`button[onclick*='startRest(\"${zone}\")']`) ||\n                          document.querySelector('#start-rest-button') ||\n                          document.querySelector('.rest-button');\n        \n        if (restButton) {\n            restButton.focus();\n            restButton.scrollIntoView({ behavior: 'smooth', block: 'center' });\n            \n            // Add visual highlight\n            restButton.style.animation = 'pulse 2s infinite';\n            setTimeout(() => {\n                restButton.style.animation = '';\n            }, 10000);\n            \n            console.log('[Notifications] Focused rest button for zone:', zone);\n        } else {\n            console.log('[Notifications] Rest button not found for zone:', zone);\n        }\n    }\n\n    // Play audio alert\n    playAudioAlert() {\n        try {\n            // Create audio context for better mobile support\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            \n            // Create beep sound\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n            \n            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\n            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);\n            \n            oscillator.start(audioContext.currentTime);\n            oscillator.stop(audioContext.currentTime + 0.5);\n            \n            console.log('[Notifications] Audio alert played');\n            \n        } catch (error) {\n            console.log('[Notifications] Audio alert failed:', error);\n        }\n    }\n\n    // Trigger vibration\n    triggerVibration() {\n        if ('vibrate' in navigator) {\n            navigator.vibrate([200, 100, 200, 100, 200]);\n            console.log('[Notifications] Vibration triggered');\n        }\n    }\n\n    // Get rest time for zone\n    getRestTimeForZone(zone) {\n        const WBGT_ZONES = {\n            \"white\": { \"work\": 60, \"rest\": 15 },\n            \"green\": { \"work\": 45, \"rest\": 15 },\n            \"yellow\": { \"work\": 30, \"rest\": 15 },\n            \"red\": { \"work\": 30, \"rest\": 30 },\n            \"black\": { \"work\": 15, \"rest\": 30 },\n            \"test\": { \"work\": 7/60, \"rest\": 10 },\n            \"cut-off\": { \"work\": 0, \"rest\": 30 }\n        };\n        \n        return WBGT_ZONES[zone]?.rest || 15;\n    }\n\n    // Mark user as notified\n    markAsNotified() {\n        if (this.serviceWorker && this.username) {\n            this.sendMessageToSW('MARK_NOTIFIED', { username: this.username });\n            console.log('[Notifications] Marked user as notified');\n        }\n    }\n\n    // Cleanup when leaving page\n    cleanup() {\n        console.log('[Notifications] Cleaning up notification manager');\n        this.stopMonitoring();\n    }\n}\n\n// Global instance\nwindow.enhancedNotificationManager = new EnhancedNotificationManager();\n\n\n// Auto-cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    if (window.enhancedNotificationManager) {\n        window.enhancedNotificationManager.cleanup();\n    }\n});\n\nconsole.log('[Notifications] Enhanced notification system loaded with refresh button support');","size_bytes":21233},"static/firebase-messaging-sw.js":{"content":"// Firebase Cloud Messaging Service Worker\nimportScripts('https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js');\nimportScripts('https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js');\n\n// Firebase configuration with your actual credentials\nconst firebaseConfig = {\n  apiKey: \"AIzaSyBaT8NPePn_crgrLUDHscuBzZwOTg54Mpw\",\n  authDomain: \"thermopal-9b302.firebaseapp.com\",\n  projectId: \"thermopal-9b302\",\n  storageBucket: \"thermopal-9b302.firebasestorage.app\",\n  messagingSenderId: \"212325894246\",\n  appId: \"1:212325894246:web:92f39a3ca0553a78bac5a7\"\n};\n\n// Initialize Firebase\nfirebase.initializeApp(firebaseConfig);\n\n// Initialize Firebase Cloud Messaging\nconst messaging = firebase.messaging();\n\n// Handle background messages with enhanced persistence and reminder system\nmessaging.onBackgroundMessage(function(payload) {\n  console.log('[firebase-messaging-sw.js] Received background message:', payload);\n\n  const notificationTitle = payload.notification?.title || payload.data?.title || 'Work Cycle Alert';\n  const notificationBody = payload.notification?.body || payload.data?.body || 'Your work cycle has ended. Time for rest!';\n  const username = payload.data?.username || 'unknown';\n  const zone = payload.data?.zone || 'unknown';\n\n  const notificationOptions = {\n    body: notificationBody,\n    icon: 'https://thermopal.onrender.com/static/icon.png',\n    badge: 'https://thermopal.onrender.com/static/icon.png',\n    tag: `wbgt-work-complete-${username}`, // Consistent tag for work completion\n    requireInteraction: true,\n    vibrate: [1000, 500, 1000, 500, 1000, 500, 1500],\n    silent: false,\n    renotify: true,\n    timestamp: Date.now(),\n    persistent: true,\n    dir: 'auto',\n    lang: 'en',\n    actions: [\n      {\n        action: 'start-rest',\n        title: 'Start Rest',\n        icon: 'https://thermopal.onrender.com/static/icon.png'\n      },\n      {\n        action: 'view-app',\n        title: 'Open App',\n        icon: 'https://thermopal.onrender.com/static/icon.png'\n      }\n    ],\n    data: {\n      url: payload.data?.url || `https://thermopal.onrender.com/dashboard/${username}`,\n      username: username,\n      timestamp: Date.now(),\n      zone: zone,\n      type: 'work_complete'\n    }\n  };\n\n  // Show notification with enhanced background support\n  console.log('[firebase-messaging-sw.js] Showing background notification for:', username);\n\n  // Store notification data for reminder system and show notification\n  const notificationPromise = self.registration.showNotification(notificationTitle, notificationOptions);\n\n  notificationPromise.then(() => {\n    console.log('[firebase-messaging-sw.js] Background notification shown successfully');\n    // Start progressive reminder system in background (first reminder after 5 seconds)\n    startBackgroundProgressiveReminderSystem(username, zone);\n  }).catch(error => {\n    console.error('[firebase-messaging-sw.js] Failed to show background notification:', error);\n  });\n\n  return notificationPromise;\n});\n\n// Background progressive reminder system\nlet backgroundReminderInterval = null;\nlet backgroundFirstReminderTimeout = null;\n\nfunction startBackgroundProgressiveReminderSystem(username, zone) {\n  console.log('[firebase-messaging-sw.js] Starting background progressive reminder system for:', username);\n\n  // Clear any existing reminders\n  clearBackgroundReminders();\n\n  // Set up first reminder after 5 seconds (when user dismisses)\n  // This will be triggered when the notification is dismissed\n}\n\nfunction startBackgroundReminderSystem(username, zone) {\n  // Legacy function - redirect to progressive system\n  startBackgroundProgressiveReminderSystem(username, zone);\n}\n\nfunction startBackgroundContinuousReminders(username, zone) {\n  console.log('[firebase-messaging-sw.js] Starting continuous background reminders for:', username);\n\n  // Clear any existing reminders\n  clearBackgroundReminders();\n\n  // Show initial reminder immediately\n  showBackgroundReminder(username, zone);\n\n  // Set up interval for continuous reminders every 10 seconds\n  backgroundReminderInterval = setInterval(() => {\n    console.log('[firebase-messaging-sw.js] Showing scheduled background reminder (10 second interval)');\n    showBackgroundReminder(username, zone);\n  }, 10000); // Every 10 seconds as requested\n\n}\n\nfunction clearBackgroundReminders() {\n  if (backgroundReminderInterval) {\n    clearInterval(backgroundReminderInterval);\n    backgroundReminderInterval = null;\n  }\n  if (backgroundFirstReminderTimeout) {\n    clearTimeout(backgroundFirstReminderTimeout);\n    backgroundFirstReminderTimeout = null;\n  }\n}\n\nfunction showBackgroundReminder(username, zone) {\n  const reminderTitle = \"Rest Cycle Reminder!\";\n  const reminderBody = `${username}, you still need to start your rest cycle after completing ${zone?.toUpperCase() || 'WORK'} zone work.`;\n\n  const reminderOptions = {\n    body: reminderBody,\n    icon: '/static/icon.png',\n    badge: '/static/icon.png',\n    tag: 'wbgt-reminder-' + Date.now(),\n    requireInteraction: true,\n    vibrate: [1000, 300, 1000, 300, 1000],\n    silent: false,\n    renotify: true,\n    timestamp: Date.now(),\n    persistent: true,\n    actions: [\n      {\n        action: 'start-rest',\n        title: 'Start Rest Now',\n        icon: '/static/icon.png'\n      },\n      {\n        action: 'view-app',\n        title: 'Open App',\n        icon: '/static/icon.png'\n      }\n    ],\n    data: {\n      url: 'https://thermopal.onrender.com/dashboard',\n      username: username,\n      zone: zone,\n      timestamp: Date.now(),\n      isReminder: true\n    }\n  };\n\n  console.log('[firebase-messaging-sw.js] Showing background reminder notification');\n  self.registration.showNotification(reminderTitle, reminderOptions);\n}\n\n// Clear reminders when rest is started or handle dismiss actions\nself.addEventListener('message', function(event) {\n  if (event.data && event.data.type === 'clear-reminders') {\n    console.log('[firebase-messaging-sw.js] Clearing background reminders');\n    clearBackgroundReminders();\n  } else if (event.data && event.data.type === 'notification-dismissed') {\n    console.log('[firebase-messaging-sw.js] Notification dismissed - starting progressive reminders');\n    const { username, zone } = event.data;\n    \n    // Start first reminder after 5 seconds\n    backgroundFirstReminderTimeout = setTimeout(() => {\n      console.log('[firebase-messaging-sw.js] First reminder after dismiss (5 seconds)');\n      startBackgroundContinuousReminders(username, zone);\n    }, 5000);\n  }\n});\n\n// Handle notification clicks with enhanced mobile support\nself.addEventListener('notificationclick', function(event) {\n  console.log('[firebase-messaging-sw.js] Notification click received on mobile:', event);\n\n  event.notification.close();\n\n  const notificationData = event.notification.data || {};\n  const dashboardUrl = notificationData.url || 'https://thermopal.onrender.com/dashboard';\n\n  if (event.action === 'start-rest') {\n    // Clear background reminders immediately\n    if (backgroundReminderInterval) {\n      clearInterval(backgroundReminderInterval);\n      backgroundReminderInterval = null;\n    }\n\n    // Focus existing window or open new one for start rest action\n    event.waitUntil(\n      clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {\n        // Try to find existing dashboard window\n        for (const client of clientList) {\n          if (client.url.includes('/dashboard') && 'focus' in client) {\n            console.log('Focusing existing dashboard window');\n            // Send message to clear client-side reminders too\n            client.postMessage({\n              type: 'clear-reminders'\n            });\n            return client.focus();\n          }\n        }\n        // Open new window if no existing one found\n        console.log('Opening new dashboard window for start rest');\n        if (clients.openWindow) {\n          return clients.openWindow(dashboardUrl);\n        }\n      }).then(client => {\n        // Send message to client to trigger start rest action\n        if (client) {\n          client.postMessage({\n            type: 'notification-click',\n            action: 'start-rest',\n            username: notificationData.username\n          });\n          // Also send clear reminders message\n          client.postMessage({\n            type: 'clear-reminders'\n          });\n        }\n      })\n    );\n  } else if (event.action === 'view-app') {\n    // Open the app\n    event.waitUntil(\n      clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {\n        for (const client of clientList) {\n          if ('focus' in client) {\n            console.log('Focusing existing app window');\n            return client.focus();\n          }\n        }\n        console.log('Opening new app window');\n        if (clients.openWindow) {\n          return clients.openWindow('https://thermopal.onrender.com');\n        }\n      })\n    );\n  } else {\n    // Default action - open dashboard\n    event.waitUntil(\n      clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {\n        for (const client of clientList) {\n          if (client.url.includes('/dashboard') && 'focus' in client) {\n            console.log('Focusing existing dashboard (default action)');\n            return client.focus();\n          }\n        }\n        console.log('Opening new dashboard window (default action)');\n        if (clients.openWindow) {\n          return clients.openWindow(dashboardUrl);\n        }\n      })\n    );\n  }\n});","size_bytes":9533},"static/firebase-notifications.js":{"content":"// Firebase push notifications integration\nlet messaging = null;\nlet currentUser = null;\nlet isMobileDevice = false;\nlet firebaseAudioInitialized = false;\n\n// Detect mobile browser\nfunction detectMobileDevice() {\n    const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    isMobileDevice = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n    return isMobileDevice;\n}\n\n// Initialize Firebase audio context after user interaction\nfunction initializeFirebaseAudio() {\n    if (!firebaseAudioInitialized && !firebaseAudioContext) {\n        try {\n            firebaseAudioContext = new (window.AudioContext || window.webkitAudioContext)();\n            firebaseAudioInitialized = true;\n            console.log('Firebase audio context initialized for mobile');\n        } catch (e) {\n            console.log('Could not initialize Firebase audio context:', e);\n        }\n    }\n}\n\n// Initialize Firebase notifications\nasync function initializeFirebaseNotifications(username) {\n    currentUser = username;\n\n    try {\n        // Import Firebase modules\n        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');\n        const { getMessaging, getToken, onMessage } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging.js');\n\n        // Firebase configuration with your actual credentials\n        const firebaseConfig = {\n            apiKey: \"AIzaSyBaT8NPePn_crgrLUDHscuBzZwOTg54Mpw\",\n            authDomain: \"thermopal-9b302.firebaseapp.com\",\n            projectId: \"thermopal-9b302\",\n            storageBucket: \"thermopal-9b302.firebasestorage.app\",\n            messagingSenderId: \"212325894246\",\n            appId: \"1:212325894246:web:92f39a3ca0553a78bac5a7\"\n        };\n\n        // Initialize Firebase\n        const app = initializeApp(firebaseConfig);\n        messaging = getMessaging(app);\n\n        // Register service worker with enhanced scope for better background support\n        if ('serviceWorker' in navigator) {\n            try {\n                // Register Firebase messaging service worker with root scope for better coverage\n                const registration = await navigator.serviceWorker.register('/static/firebase-messaging-sw.js', {\n                    scope: '/'\n                });\n\n                // Wait for service worker to be ready\n                await navigator.serviceWorker.ready;\n                console.log('Firebase Service Worker registered and ready:', registration);\n\n                // Also register the general service worker for push notifications\n                await navigator.serviceWorker.register('/static/sw.js', {\n                    scope: '/'\n                });\n                console.log('General Service Worker registered');\n\n                // Enhanced service worker message handling\n                navigator.serviceWorker.addEventListener('message', event => {\n                    console.log('Received message from service worker:', event.data);\n                    if (event.data && event.data.type === 'notification-click') {\n                        console.log('Notification was clicked');\n                        // Handle notification click actions\n                        if (event.data.action === 'start-rest') {\n                            handleStartRestAction();\n                        }\n                    }\n                });\n\n                // Listen for service worker updates\n                registration.addEventListener('updatefound', () => {\n                    console.log('Service worker update found');\n                });\n\n            } catch (error) {\n                console.log('Service Worker registration failed:', error);\n            }\n        }\n\n        // Request notification permission with better mobile handling\n        let permission = Notification.permission;\n\n        if (permission === 'default') {\n            permission = await Notification.requestPermission();\n        }\n\n        if (permission === 'granted') {\n            console.log('Notification permission granted for mobile device');\n\n            // Get FCM registration token with service worker registration\n            try {\n                    const token = await getToken(messaging, {\n                        vapidKey: 'BLch2zbnpXdzzV_OYtZicTjbefAURKoUyBtL8blEMcTciTYLMeGrGEorwMsSrRyGZ14vmH6mqAluZ87IaITT-3U',\n                        serviceWorkerRegistration: registration\n                    });\n\n                if (token) {\n                    console.log('FCM Registration token for mobile:', token);\n\n                    // Send token to server\n                    await fetch('/save-fcm-token', {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                        body: JSON.stringify({ \n                            token: token, \n                            username: username \n                        })\n                    });\n\n                    console.log('FCM token saved to server for mobile device');\n\n                    // Set up foreground message handling\n                    onMessage(messaging, (payload) => {\n                        console.log('Foreground message received on mobile:', payload);\n\n                        // Create notification even when app is in foreground\n                        if (payload.notification) {\n                            // Show browser notification\n                            const notification = new Notification(payload.notification.title, {\n                                body: payload.notification.body,\n                                icon: '/static/icon.png',\n                                badge: '/static/icon.png',\n                                tag: 'wbgt-notification',\n                                requireInteraction: true,\n                                vibrate: [500, 300, 500, 300, 500],\n                                silent: false\n                            });\n\n                            // Handle notification click\n                            notification.onclick = function() {\n                                window.focus();\n                                notification.close();\n                            };\n\n                            // Also trigger in-app notification\n                            handleFirebaseNotificationEvent({\n                                username: currentUser,\n                                title: payload.notification.title,\n                                body: payload.notification.body\n                            });\n                        }\n                    });\n\n                    return true;\n                } else {\n                    console.log('No registration token available for mobile.');\n                    return false;\n                }\n            } catch (err) {\n                console.log('An error occurred while retrieving mobile token:', err);\n                return false;\n            }\n        } else {\n            console.log('Unable to get notification permission on mobile.');\n            return false;\n        }\n\n    } catch (error) {\n        console.log('Error initializing Firebase notifications on mobile:', error);\n        return false;\n    }\n}\n\n// Handle foreground messages\nfunction handleForegroundMessages() {\n    if (!messaging) return;\n\n    const { onMessage } = firebase.messaging;\n\n    onMessage(messaging, (payload) => {\n        console.log('Message received in foreground:', payload);\n\n        // Show notification even when app is open\n        if (payload.notification) {\n            // Create a more prominent notification\n            new Notification(payload.notification.title, {\n                body: payload.notification.body,\n                icon: '/generated-icon.png',\n                badge: '/generated-icon.png',\n                tag: 'work-cycle-notification',\n                requireInteraction: true,\n                vibrate: [200, 100, 200, 100, 200]\n            });\n\n            // Also show an in-app alert\n            showInAppNotification(payload.notification.title, payload.notification.body);\n        }\n    });\n}\n\n// Show Firebase work complete notification manually\nfunction showFirebaseWorkCompleteNotification(data) {\n    console.log('Showing Firebase work complete notification for:', data.username);\n    \n    // Create a browser notification if permission granted\n    if (Notification.permission === 'granted') {\n        const notification = new Notification('Work Cycle Complete!', {\n            body: `Your work cycle has ended. Time to start your rest cycle!`,\n            icon: '/static/icon-192.png',\n            badge: '/static/icon-192.png',\n            tag: 'wbgt-notification',\n            requireInteraction: true,\n            vibrate: [500, 300, 500, 300, 500],\n            silent: false\n        });\n\n        notification.onclick = function() {\n            window.focus();\n            notification.close();\n        };\n    }\n    \n    // Also show in-app notification\n    showInAppNotification('Work Cycle Complete!', 'Your work cycle has ended. Time to start your rest cycle!');\n    \n    // Trigger the work modal if available\n    if (typeof workModal !== 'undefined') {\n        workModal.showWorkCompletionModal(data);\n    }\n}\n\n// Show in-app notification\nfunction showInAppNotification(title, body) {\n    // Create a prominent in-app notification\n    const notification = document.createElement('div');\n    notification.className = 'fixed top-4 right-4 bg-red-500 text-white p-4 rounded-lg shadow-lg z-50 max-w-sm';\n    notification.innerHTML = `\n        <div class=\"flex items-center\">\n            <div class=\"flex-1\">\n                <h4 class=\"font-bold\">${title}</h4>\n                <p class=\"text-sm\">${body}</p>\n            </div>\n            <button class=\"ml-2 text-white hover:text-gray-300\" onclick=\"stopAllFirebaseSounds(); this.parentElement.parentElement.remove();\">\n                ✕\n            </button>\n        </div>\n    `;\n\n    document.body.appendChild(notification);\n\n    // Auto-remove after 10 seconds\n    setTimeout(() => {\n        if (notification.parentElement) {\n            notification.remove();\n        }\n    }, 10000);\n}\n\n// Handle Firebase notification events from server\nfunction handleFirebaseNotificationEvent(data) {\n    if (data.username === currentUser && data.title && data.body) {\n        console.log('Received Firebase notification for current user:', data);\n\n        // Show notification with Start/Dismiss actions\n        showRestCycleNotification(data.title, data.body, data.actions);\n\n        // Extract zone from notification body to get correct rest duration\n        const zoneMatch = data.body.match(/Your (\\w+) zone/i);\n        const zone = zoneMatch ? zoneMatch[1].toLowerCase() : 'unknown';\n        const restMinutes = getRestMinutesForZone(zone);\n\n        // Start reminder system that will activate after 10 seconds if user doesn't start rest\n        if (typeof startRestReminderSystem === 'function') {\n            startRestReminderSystem(zone, restMinutes);\n        }\n    }\n}\n\n// Global variables for Firebase sound management\nlet firebaseAudioContext = null;\nlet firebaseActiveOscillators = [];\n\n// Function to stop all Firebase sounds\nfunction stopAllFirebaseSounds() {\n    // Stop all active oscillators\n    firebaseActiveOscillators.forEach(oscillator => {\n        try {\n            oscillator.stop();\n        } catch (e) {\n            // Oscillator may already be stopped\n        }\n    });\n    firebaseActiveOscillators = [];\n\n    // Close current audio context if it exists\n    if (firebaseAudioContext && firebaseAudioContext.state !== 'closed') {\n        try {\n            firebaseAudioContext.close();\n        } catch (e) {\n            // Context may already be closed\n        }\n    }\n    firebaseAudioContext = null;\n\n    console.log('All Firebase sounds stopped');\n}\n\n// Show rest cycle notification with action buttons\nfunction showRestCycleNotification(title, body, actions) {\n    // Create prominent notification overlay with action buttons\n    const notificationOverlay = document.createElement('div');\n    notificationOverlay.id = 'firebase-notification-overlay';\n    notificationOverlay.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';\n    notificationOverlay.innerHTML = `\n        <div class=\"bg-white p-8 rounded-lg shadow-xl max-w-md mx-4 text-center\">\n            <div class=\"text-6xl mb-4\">⏰</div>\n            <h3 class=\"text-2xl font-bold mb-4 text-red-600\">${title}</h3>\n            <p class=\"text-gray-700 mb-8 text-lg\">${body}</p>\n            <div class=\"flex space-x-4 justify-center\">\n                <button id=\"start-rest-btn\" class=\"bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 font-bold text-lg\">\n                    Start Rest\n                </button>\n                <button id=\"dismiss-notification-btn\" class=\"bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 font-bold text-lg\">\n                    Dismiss\n                </button>\n            </div>\n        </div>\n    `;\n\n    document.body.appendChild(notificationOverlay);\n\n    // Add event listeners for action buttons\n    document.getElementById('start-rest-btn').addEventListener('click', function() {\n        stopAllFirebaseSounds();\n        handleStartRestAction();\n        notificationOverlay.remove();\n    });\n\n    document.getElementById('dismiss-notification-btn').addEventListener('click', function() {\n        // Stop sounds immediately\n        stopAllFirebaseSounds();\n\n        // Remove the notification overlay\n        notificationOverlay.remove();\n\n        // Send dismiss message to service worker for progressive reminder system\n        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n            navigator.serviceWorker.controller.postMessage({\n                type: 'notification-dismissed',\n                username: currentUser,\n                zone: zone || 'unknown'\n            });\n        }\n\n        // Disable WBGT zones immediately when dismissed\n        if (typeof disableZoneButtons === 'function') {\n            disableZoneButtons();\n        }\n\n        // Extract zone from notification body to restart reminder system\n        const zoneMatch = body.match(/Your (\\w+) zone/i);\n        const zone = zoneMatch ? zoneMatch[1].toLowerCase() : 'unknown';\n        const restMinutes = getRestMinutesForZone(zone);\n\n        // Start the reminder system (will remind again after 12 seconds)\n        startFirebaseReminderSystem(title, body);\n    });\n\n    // Add vibration pattern for mobile devices\n    if ('vibrate' in navigator) {\n        navigator.vibrate([500, 300, 500, 300, 500, 300, 800]);\n    }\n\n    // Don't play alert sound here - let work-notifications.js handle it to avoid duplicates\n}\n\n// Handle start rest action\nfunction handleStartRestAction() {\n    console.log('User clicked Start Rest button');\n\n    // Clear all Firebase reminders and sounds\n    clearFirebaseReminders();\n    stopAllFirebaseSounds();\n\n    // Re-enable zone buttons immediately\n    if (typeof enableZoneButtons === 'function') {\n        enableZoneButtons();\n    }\n\n    // Make request to start rest cycle\n    fetch('/start_rest', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded',\n        },\n        body: new URLSearchParams({\n            username: currentUser\n        })\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.success) {\n            console.log('Rest cycle started successfully');\n\n            // Update the dashboard immediately\n            if (typeof updateDashboard === 'function') {\n                updateDashboard();\n            }\n\n            // Call the dashboard function if available\n            if (typeof startRestCycleFromNotification === 'function') {\n                startRestCycleFromNotification();\n            }\n        } else {\n            console.error('Failed to start rest cycle:', data.error);\n            alert('Failed to start rest cycle: ' + (data.error || 'Unknown error'));\n        }\n    })\n    .catch(error => {\n        console.error('Error starting rest cycle:', error);\n        alert('Error starting rest cycle. Please try again.');\n    });\n}\n\nlet firebaseReminderInterval = null;\n\n// Start reminder system that repeats every 10 seconds\nfunction startFirebaseReminderSystem(title, body) {\n    // Clear any existing reminders\n    clearFirebaseReminders();\n\n    console.log('Starting Firebase reminder system - will remind in 12 seconds, then every 10 seconds');\n\n    // Start reminders after 12 seconds if rest cycle hasn't started\n    setTimeout(() => {\n        console.log('Starting Firebase reminders - 12 seconds have passed');\n\n        // Show initial reminder\n        showFirebaseReminder(title, body);\n\n        // Set up interval to show reminder every 10 seconds - this will continue indefinitely until cleared\n        firebaseReminderInterval = setInterval(() => {\n            console.log('Showing Firebase reminder every 10 seconds');\n            showFirebaseReminder(title, body);\n        }, 10000); // 10 seconds\n\n    }, 12000); // 12 seconds\n}\n\n// Show Firebase reminder notification\nfunction showFirebaseReminder(title, body) {\n    console.log('Showing Firebase reminder notification');\n\n    // Remove any existing reminder\n    const existingReminder = document.getElementById('firebase-reminder-banner');\n    if (existingReminder) {\n        existingReminder.remove();\n    }\n\n    // Disable zone buttons during reminder\n    if (typeof disableZoneButtons === 'function') {\n        disableZoneButtons();\n    }\n\n    // Create reminder banner\n    const reminderBanner = document.createElement('div');\n    reminderBanner.id = 'firebase-reminder-banner';\n    reminderBanner.className = 'fixed inset-x-4 top-4 bg-red-600 text-white p-6 rounded-lg shadow-2xl z-50 border-4 border-red-800 animate-pulse';\n    reminderBanner.innerHTML = `\n        <div class=\"flex items-center justify-between\">\n            <div class=\"flex items-center\">\n                <div class=\"text-3xl mr-4 animate-bounce\">🚨</div>\n                <div>\n                    <h4 class=\"font-bold text-xl\">${title}</h4>\n                    <p class=\"text-lg mt-2\">${body}</p>\n                </div>\n            </div>\n            <div class=\"flex space-x-2 ml-4\">\n                <button id=\"reminder-start-rest\" class=\"bg-green-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-green-600\">\n                    Start Rest\n                </button>\n                <button id=\"reminder-dismiss\" class=\"bg-gray-500 text-white px-4 py-2 rounded-lg font-bold hover:bg-gray-600\">\n                    Dismiss\n                </button>\n            </div>\n        </div>\n    `;\n\n    document.body.appendChild(reminderBanner);\n\n    // Add event listeners\n    document.getElementById('reminder-start-rest').addEventListener('click', function() {\n        stopAllFirebaseSounds();\n        handleStartRestAction();\n        reminderBanner.remove();\n    });\n\n    document.getElementById('reminder-dismiss').addEventListener('click', function() {\n        // Stop sounds immediately\n        stopAllFirebaseSounds();\n\n        // Remove the current banner\n        reminderBanner.remove();\n\n        // Keep zones disabled - user must start rest to re-enable them\n        if (typeof disableZoneButtons === 'function') {\n            disableZoneButtons();\n        }\n\n        // Keep the reminder interval running - it will show another reminder in 10 seconds\n        console.log('Firebase banner dismissed - reminder system continues running, will show again in 10 seconds');\n    });\n\n    // REMOVED: Auto-remove timeout - banner persists until user action\n\n    // Enhanced vibration for mobile\n    if ('vibrate' in navigator) {\n        navigator.vibrate([800, 300, 800, 300, 800, 300, 1000]);\n    }\n\n    // Play enhanced reminder sound with multiple attempts\n    playFirebaseReminderSound();\n\n    // Try to play system notification sound as backup\n    try {\n        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLPfCsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjiM1fLNeSgGJXjH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAZBjOJ1fLOeSsFJHfH8N2QQAo=');\n        audio.volume = 1.0;\n        audio.play().catch(e => console.log('Backup audio failed:', e));\n    } catch (e) {\n        console.log('Could not play backup audio:', e);\n    }\n}\n\n// Clear Firebase reminders\nfunction clearFirebaseReminders() {\n    if (firebaseReminderInterval) {\n        clearInterval(firebaseReminderInterval);\n        firebaseReminderInterval = null;\n        console.log('Firebase reminders cleared');\n    }\n\n    // Remove any existing reminder banner\n    const reminderBanner = document.getElementById('firebase-reminder-banner');\n    if (reminderBanner) {\n        reminderBanner.remove();\n    }\n\n    // Stop all Firebase sounds immediately\n    stopAllFirebaseSounds();\n\n    // Re-enable zone buttons\n    if (typeof enableZoneButtons === 'function') {\n        enableZoneButtons();\n    }\n}\n\n// Play Firebase alert sound\nfunction playFirebaseAlertSound() {\n    try {\n        const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n        function createFirebaseBeep(startTime, frequency, duration) {\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n\n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n\n            oscillator.frequency.value = frequency;\n            oscillator.type = 'sine';\n\n            gainNode.gain.setValueAtTime(0.5, startTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);\n\n            oscillator.start(startTime);\n            oscillator.stop(startTime + duration);\n        }\n\n        const now = audioContext.currentTime;\n        createFirebaseBeep(now, 900, 0.8);\n        createFirebaseBeep(now + 1.0, 700, 0.8);\n        createFirebaseBeep(now + 2.0, 900, 1.0);\n        createFirebaseBeep(now + 3.2, 1000, 1.2);\n\n    } catch (e) {\n        console.log('Could not play Firebase alert sound:', e);\n    }\n}\n\n// Play Firebase reminder sound\nfunction playFirebaseReminderSound() {\n    try {\n        // Stop any existing Firebase sounds first\n        stopAllFirebaseSounds();\n\n        firebaseAudioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n        function createReminderBeep(startTime, frequency, duration) {\n            const oscillator = firebaseAudioContext.createOscillator();\n            const gainNode = firebaseAudioContext.createGain();\n\n            oscillator.connect(gainNode);\n            gainNode.connect(firebaseAudioContext.destination);\n\n            oscillator.frequency.value = frequency;\n            oscillator.type = 'sine';\n\n            gainNode.gain.setValueAtTime(0.6, startTime);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);\n\n            oscillator.start(startTime);\n            oscillator.stop(startTime + duration);\n\n            // Track oscillator for potential early stopping\n            firebaseActiveOscillators.push(oscillator);\n\n            // Remove from tracking when it naturally ends\n            oscillator.addEventListener('ended', () => {\n                const index = firebaseActiveOscillators.indexOf(oscillator);\n                if (index > -1) {\n                    firebaseActiveOscillators.splice(index, 1);\n                }\n            });\n        }\n\n        const now = firebaseAudioContext.currentTime;\n        createReminderBeep(now, 1000, 0.8);\n        createReminderBeep(now + 1.0, 800, 0.8);\n        createReminderBeep(now + 2.0, 1200, 1.0);\n\n    } catch (e) {\n        console.log('Could not play Firebase reminder sound:', e);\n    }\n}\n\n// Make clearFirebaseReminders available globally\nwindow.clearFirebaseReminders = clearFirebaseReminders;\n\n// Check for pending work completion state when page loads\nfunction checkPendingWorkCompletion() {\n    if (!currentUser) return;\n\n    // Make a request to check current user state\n    fetch(`/get_user_state/${currentUser}`)\n        .then(response => response.json())\n        .then(data => {\n            console.log('Firebase checking pending work completion:', data);\n            \n            if (data.work_completed && data.pending_rest && data.zone) {\n                console.log('Found pending work completion - showing notification banner');\n\n                // Show the notification banner immediately\n                const title = \"Work Cycle Complete!\";\n                const restMinutes = getRestMinutesForZone(data.zone);\n                let body = `Your work cycle has ended. Time to start rest cycle!`;\n\n                // Show the notification immediately with maximum visibility\n                showRestCycleNotification(title, body);\n\n                // Disable zone buttons immediately\n                if (typeof disableZoneButtons === 'function') {\n                    disableZoneButtons();\n                }\n\n                // Start the reminder system\n                startFirebaseReminderSystem(title, body);\n\n                // Enhanced feedback for returning users\n                if ('vibrate' in navigator) {\n                    navigator.vibrate([1000, 300, 1000, 300, 1000, 300, 1500]);\n                }\n                playFirebaseAlertSound();\n            }\n        })\n        .catch(error => {\n            console.log('Error checking pending work completion:', error);\n        });\n}\n\n// Initialize notifications when page loads\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Detect mobile device\n    detectMobileDevice();\n    console.log('Mobile device detected for Firebase:', isMobileDevice);\n\n    // Initialize audio context on first user interaction for mobile\n    if (isMobileDevice) {\n        const initFirebaseAudioOnTouch = () => {\n            initializeFirebaseAudio();\n            document.removeEventListener('touchstart', initFirebaseAudioOnTouch);\n            document.removeEventListener('click', initFirebaseAudioOnTouch);\n        };\n\n        document.addEventListener('touchstart', initFirebaseAudioOnTouch);\n        document.addEventListener('click', initFirebaseAudioOnTouch);\n    }\n\n    // Only initialize if we have a current user\n    if (typeof currentUser !== 'undefined' && currentUser) {\n        initializeFirebaseNotifications(currentUser);\n\n        // Check for pending work completion after a short delay to ensure page is fully loaded\n        setTimeout(() => {\n            checkPendingWorkCompletion();\n        }, 1000);\n    }\n});","size_bytes":27644},"static/main.js":{"content":"// WBGT Tracker - Main JavaScript\n// This file consolidates and fixes the Socket.io event handlers and system interaction\n\n// Global variables  \nlet timerInterval = null;\nlet lastZone = null;\nlet lastEndTime = null;\nlet socketio = null;\nlet pollingInterval = null;\nlet serverTimeOffset = 0; // Server time synchronization\nlet zoneButtonsContainer = null;\n\n// Server time synchronization functions\nfunction getServerSynchronizedTime() {\n  return new Date(Date.now() + serverTimeOffset);\n}\n\nasync function synchronizeWithServerTime() {\n  try {\n    const response = await fetch('/get_server_time');\n    const data = await response.json();\n\n    const serverTimestamp = data.timestamp * 1000;\n    const localTimestamp = Date.now();\n    serverTimeOffset = serverTimestamp - localTimestamp;\n\n    console.log(`Server time sync: offset = ${serverTimeOffset}ms`);\n  } catch (error) {\n    console.error('Failed to sync with server time:', error);\n    serverTimeOffset = 0;\n  }\n}\n\n// Initialize Socket.io connection\ndocument.addEventListener('DOMContentLoaded', async function() {\n  // First, synchronize with server time\n  await synchronizeWithServerTime();\n\n  // Re-sync every 30 seconds\n  setInterval(synchronizeWithServerTime, 30000);\n\n  // Get username and role from the page (use window.currentUser and window.userRole from dashboard template)\n\n  // Initialize Enhanced Notification System\n  if (window.enhancedNotificationManager && window.currentUser) {\n    console.log('Initializing enhanced notifications for:', window.currentUser);\n    try {\n      await window.enhancedNotificationManager.initialize(window.currentUser);\n      console.log('Enhanced notification system initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize enhanced notifications:', error);\n    }\n  }\n\n  // Initialize Socket.io\n  if (typeof io !== 'undefined') {\n    socketio = io();\n\n    // Socket.io connection handlers\n    socketio.on('connect', function() {\n      console.log('Socket.io connected successfully');\n      fetchSystemStatus();\n      updateDashboard();\n      if (pollingInterval) {\n        stopPolling();\n      }\n    });\n\n    // Handle work complete modal\n    socketio.on('show_work_complete_modal', function(data) {\n      console.log('Received work complete modal:', data);\n      if (data.username === window.currentUser) {\n        showWorkCompleteModal(data);\n      }\n    });\n\n    socketio.on('connect_error', function(error) {\n      console.error('Socket.io connection error:', error);\n      startPolling();\n    });\n\n    socketio.on('disconnect', function(reason) {\n      console.warn('Socket.io disconnected:', reason);\n      if (reason !== 'io client disconnect') {\n        startPolling();\n      }\n    });\n\n    socketio.on('reconnect', function(attemptNumber) {\n      console.log('Socket.io reconnected after', attemptNumber, 'attempts');\n      fetchSystemStatus();\n      updateDashboard();\n      stopPolling();\n    });\n\n    socketio.on('reconnect_error', function(error) {\n      console.error('Socket.io reconnection error:', error);\n    });\n\n    // Debug all events\n    socketio.onAny((event, ...args) => {\n      console.log(`Received socket event: ${event}`, args);\n    });\n\n    // Handle system status updates\n    socketio.on('system_status_update', function(data) {\n      console.log(\"System status update received:\", data);\n      updateSystemStatusUI(data);\n    });\n\n    // Handle history updates\n    socketio.on('history_update', function(data) {\n      updateHistoryTable(data.history || []);\n\n      // Check if current user started rest cycle and clear reminders\n      if (data.history && window.currentUser) {\n        const latestEntry = data.history[data.history.length - 1];\n        if (latestEntry && latestEntry.username === window.currentUser && latestEntry.action === 'start_rest') {\n          console.log('User started rest cycle, clearing reminders');\n          if (typeof clearRestReminders === 'function') {\n            clearRestReminders();\n          }\n        }\n      }\n\n      // Update zone restrictions after history changes\n      setTimeout(checkZoneRestrictions, 500);\n    });\n\n    // Handle user updates\n    socketio.on('user_update', function(data) {\n      console.log('User update received:', data);\n      updateDashboard();\n      checkZoneRestrictions();\n    });\n\n    // Handle rest cycle completion\n    socketio.on('rest_cycle_completed', function(data) {\n      if (data.user === window.currentUser) {\n        console.log('Rest cycle completed for current user');\n        enableZoneButtons();\n        clearTimer();\n        checkZoneRestrictions();\n      }\n    });\n  } else {\n    console.error('Socket.io not loaded. Falling back to polling.');\n    startPolling();\n  }\n});\n\n// Update UI based on system status\nfunction updateSystemStatusUI(data) {\n  // Update UI based on system status\n  const zoneButtons = document.querySelector('.w-full.max-w-xs');\n  const zonesHeading = document.querySelector('h3.mt-6.text-lg.font-semibold');\n  const stopButtonContainer = document.getElementById('stop-button-container');\n\n  // First, remove any existing notifications from the page\n  const existingCutOffWarning = document.querySelector('.bg-red-100');\n  if (existingCutOffWarning) {\n    existingCutOffWarning.remove();\n  }\n\n  const existingRestWarning = document.querySelector('.bg-yellow-100');\n  if (existingRestWarning) {\n    existingRestWarning.remove();\n  }\n\n  // Handle cut-off mode\n  if (data.cut_off === true) {\n    console.log(\"Cut-off mode is active, updating UI\");\n\n    // Create and insert the cut-off warning\n    const cutOffWarning = document.createElement('div');\n    cutOffWarning.className = 'bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4';\n    cutOffWarning.innerHTML = `\n      <strong class=\"font-bold\">Cut-Off Mode Active!</strong>\n      <p class=\"text-sm\">All activities must stop. Please wait for further instructions.</p>\n    `;\n\n    // Insert in the right location\n    if (zonesHeading && zonesHeading.nextElementSibling) {\n      zonesHeading.parentNode.insertBefore(cutOffWarning, zonesHeading.nextElementSibling);\n    } else if (zoneButtons) {\n      zoneButtons.parentNode.insertBefore(cutOffWarning, zoneButtons);\n    }\n\n    // Disable zone buttons\n    if (zoneButtons) {\n      zoneButtons.style.pointerEvents = 'none';\n      zoneButtons.style.opacity = '0.5';\n    }\n\n    // Clear any active timer\n    if (window.timerInterval) {\n      clearTimer();\n      window.lastZone = null;\n      lastEndTime = null;\n    }\n\n    // Hide stop button if visible\n    if (stopButtonContainer) {\n      stopButtonContainer.style.display = 'none';\n    }\n  } \n  // Handle mandatory rest period\n  else if (data.cut_off_end_time) {\n    console.log(\"Mandatory rest period is active, updating UI\");\n\n    // Create and insert the rest warning\n    const restWarning = document.createElement('div');\n    restWarning.className = 'bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded relative mb-4';\n\n    // Format the time for better readability\n    let endTime;\n\n    // Check if the time is a string in HH:MM:SS format or a Date object\n    if (typeof data.cut_off_end_time === 'string' && data.cut_off_end_time.includes(':')) {\n      endTime = new Date();\n      const timeParts = data.cut_off_end_time.split(':');\n      endTime.setHours(parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2] || 0));\n    } else {\n      endTime = new Date(data.cut_off_end_time);\n    }\n\n    let formattedTime = endTime.toLocaleTimeString();\n\n    restWarning.innerHTML = `\n      <strong class=\"font-bold\">Mandatory Rest Period</strong>\n      <p class=\"text-sm\">Normal activities will resume after: ${formattedTime}</p>\n    `;\n\n    // Insert in the right location\n    if (zonesHeading && zonesHeading.nextElementSibling) {\n      zonesHeading.parentNode.insertBefore(restWarning, zonesHeading.nextElementSibling);\n    } else if (zoneButtons) {\n      zoneButtons.parentNode.insertBefore(restWarning, zoneButtons);\n    }\n\n    // Disable zone buttons for trainers\n    const userRole = document.querySelector('meta[name=\"user-role\"]')?.content || '';\n    if (zoneButtons && userRole === 'Trainer') {\n      zoneButtons.style.pointerEvents = 'none';\n      zoneButtons.style.opacity = '0.5';\n    }\n\n    // IMPORTANT CHANGE: Hide stop button during mandatory rest\n    if (stopButtonContainer) {\n      stopButtonContainer.style.display = 'none';\n    }\n  } \n  // Normal operation - no warnings\n  else {\n    console.log(\"Normal operation, removing warnings\");\n\n    // Re-enable zone buttons\n    if (zoneButtons) {\n      zoneButtons.style.pointerEvents = '';\n      zoneButtons.style.opacity = '';\n    }\n\n    // Make sure dashboard is updated with current state\n    if (!window.timerInterval) {\n      updateDashboard();\n    }\n  }\n}\n\n// Start a WBGT zone cycle\nfunction startZone(zone) {\n  // Prevent starting a new cycle if system is in cut-off mode\n  fetchSystemStatus().then(status => {\n    if (status.cut_off) {\n      alert('System is in cut-off mode. Cannot start new cycles.');\n      return;\n    }\n\n    if (status.cut_off_end_time) {\n      const userRole = document.querySelector('meta[name=\"user-role\"]')?.content || '';\n      if (userRole === 'Trainer') {\n        alert('Mandatory rest period is active. Cannot start new cycles.');\n        return;\n      }\n    }\n\n    // Make AJAX request to set zone\n    fetch('/set_zone', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        username: window.currentUser,\n        zone: zone\n      })\n    })\n    .then(response => {\n      if (!response.ok) {\n        return response.json().then(data => {\n          throw new Error(data.error || 'Failed to set zone');\n        });\n      }\n      return response.json();\n    })\n    .then(data => {\n      console.log('Zone set successfully:', data);\n      updateDashboard();\n    })\n    .catch(error => {\n      console.error('Error starting rest cycle:', error);\n      alert(`Error: ${error.message}`);\n    });\n  });\n}\n\n// Test cycle function\nfunction startTestCycle() {\n  // Similar to startZone but specifically for test cycle\n  startZone('test');\n}\n\n// Stop the current cycle early\nfunction stopCycleEarly() {\n  fetch('/stop_cycle', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      username: window.currentUser\n    })\n  })\n  .then(response => {\n    if (!response.ok) {\n      return response.json().then(data => {\n        throw new Error(data.error || 'Failed to stop cycle');\n      });\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log('Cycle stopped successfully:', data);\n    clearTimer();\n    updateDashboard();\n  })\n  .catch(error => {\n    console.error('Error stopping cycle:', error);\n    alert(`Error: ${error.message}`);\n  });\n}\n\n// Update dashboard with latest data\nfunction updateDashboard() {\n  if (!window.currentUser) return;\n\n  fetch(`/get_user_state/${window.currentUser}`)\n    .then(response => response.json())\n    .then(data => {\n      // Update timer display based on user state\n      if ((data.status === 'working' || data.status === 'resting') && data.end_time) {\n        startTimer(data.start_time, data.end_time, data.zone);\n      } else {\n        clearTimer();\n      }\n\n      // Update zone button states\n      checkZoneRestrictions();\n    })\n    .catch(error => {\n      console.error('Error fetching user state:', error);\n    });\n}\n\n// Start the timer display\nfunction startTimer(startTime, endTime, zone) {\n  // Check if timer is already running for the same end time and zone\n  if (timerInterval && lastZone === zone && lastEndTime === endTime) {\n    console.log('Timer already running for same zone and end time');\n    return;\n  }\n\n  // Check if we need to restart the timer\n  const zoneChanged = lastZone !== zone;\n  const endTimeChanged = lastEndTime !== endTime;\n\n  if (timerInterval && (zoneChanged || endTimeChanged)) {\n    console.log('Restarting timer - Zone changed:', zoneChanged, 'End time changed:', endTimeChanged);\n    clearTimer();\n  }\n\n  // Don't start new timer if one is already running and nothing changed\n  if (timerInterval && !zoneChanged && !endTimeChanged) {\n    return;\n  }\n\n  // Parse times with exact precision (no milliseconds)\n  const startDate = parseTimeString(startTime);\n  const endDate = parseTimeString(endTime, true, startTime);\n\n  // Store these for reference\n  lastZone = zone;\n  lastEndTime = endTime;\n\n  // Log for debugging\n  console.log(`Starting timer for ${zone} zone from ${startTime} to ${endTime}`);\n\n  // Update the timer display\n  const timerElement = document.getElementById('timer');\n  if (!timerElement) return;\n\n  // Precise timer calculation for consistent display across platforms\n  function updateTimerDisplay() {\n    const now = getServerSynchronizedTime(); // Use server-synchronized time\n    // Calculate exact remaining time in milliseconds, then round up to next second\n    const timeLeftMs = Math.max(0, endDate - now);\n    const timeLeft = Math.ceil(timeLeftMs / 1000); // Round UP for consistency (matches monitor.html)\n    const minutes = Math.floor(timeLeft / 60);\n    const seconds = timeLeft % 60;\n\n    // Update timer display element\n    const countdownElement = document.getElementById('countdown');\n    if (countdownElement) {\n      countdownElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    }\n\n    // Stop timer when it reaches zero\n    if (timeLeft <= 0) {\n      clearTimer();\n      updateDashboard();\n      return false;\n    }\n    return true;\n  }\n\n  // Show initial time immediately\n  updateTimerDisplay();\n\n  // TIMER FIX: For first second, always show exact zone duration (60:00 for white)\n  // This ensures the timer always starts with the exact zone duration\n  const zoneDuration = zoneDurations[zone] || 0;\n\n  // Start the interval timer using the precise update function\n  timerInterval = setInterval(() => {\n    if (!updateTimerDisplay()) {\n      clearTimer(); // Timer finished, stop the interval\n    }\n  }, 1000);\n\n  // Show stop button when timer is active\n  const stopButtonContainer = document.getElementById('stop-button-container');\n  if (stopButtonContainer) {\n    stopButtonContainer.style.display = 'block';\n  }\n\n  // Show the stop button\n  const stopButton = document.getElementById('stop-button-container');\n  if (stopButton) {\n    stopButton.style.display = 'block';\n  }\n}\n\n// Clear the timer\nfunction clearTimer() {\n  if (timerInterval) {\n    clearInterval(timerInterval);\n    timerInterval = null;\n  }\n\n  // Reset the timer display if it exists\n  const timerElement = document.getElementById('timer');\n  if (timerElement) {\n    timerElement.textContent = '--:--';\n  }\n\n  // Hide the stop button\n  const stopButton = document.getElementById('stop-button-container');\n  if (stopButton) {\n    stopButton.style.display = 'none';\n  }\n}\n\n// Modal handling functions\nfunction showWorkCompleteModal(data) {\n  const modal = document.getElementById('work-complete-modal');\n  if (!modal) return;\n  \n  const title = document.getElementById('modal-title');\n  const message = document.getElementById('modal-message');\n  \n  if (title) title.textContent = data.title;\n  if (message) message.textContent = data.message;\n  \n  // Show modal\n  modal.classList.remove('hidden');\n  \n  console.log('Work complete modal shown for:', data.username);\n}\n\nfunction hideWorkCompleteModal() {\n  const modal = document.getElementById('work-complete-modal');\n  if (modal) {\n    modal.classList.add('hidden');\n  }\n}\n\n// Parse a time string into a Date object with exact precision\nfunction parseTimeString(timeStr, isEndTime = false, startTime = null) {\n  if (!timeStr) return new Date();\n\n  const now = new Date();\n  const [hours, minutes, seconds] = timeStr.split(':').map(Number);\n\n  // Create a new date with seconds precision, no milliseconds\n  const date = new Date(\n    now.getFullYear(),\n    now.getMonth(),\n    now.getDate(),\n    hours || 0,\n    minutes || 0,\n    seconds || 0,\n    0  // explicitly set milliseconds to 0 for exact timing\n  );\n\n  // Handle midnight rollover: if this is an end time and it's earlier than start time,\n  // it means the end time is on the next day\n  if (isEndTime && startTime) {\n    const startHours = parseInt(startTime.split(':')[0]);\n    const endHours = hours || 0;\n    \n    // If end time is significantly earlier than start time, assume next day\n    // Using 12-hour threshold to handle cases like 23:xx to 01:xx\n    if (endHours < startHours && (startHours - endHours) > 12) {\n      date.setDate(date.getDate() + 1);\n      console.log(`Midnight rollover detected: ${timeStr} moved to next day`);\n    }\n  }\n\n  return date;\n}\n\n// Fetch system status via AJAX\nfunction fetchSystemStatus() {\n  return fetch('/get_system_status')\n    .then(response => response.json())\n    .then(data => {\n      console.log(\"Fetched system status:\", data);\n      updateSystemStatusUI(data);\n      return data;\n    })\n    .catch(error => {\n      console.error(\"Error fetching system status:\", error);\n      return {}; // Return empty object on error\n    });\n}\n\n// Polling mechanism for when socket connection is lost\nfunction startPolling() {\n  if (!pollingInterval) {\n    console.log(\"Starting polling for updates\");\n    pollingInterval = setInterval(fetchSystemStatus, 5000); // Poll every 5 seconds\n  }\n}\n\nfunction stopPolling() {\n  if (pollingInterval) {\n    console.log(\"Stopping polling for updates\");\n    clearInterval(pollingInterval);\n    pollingInterval = null;\n  }\n}\n\n// Update history table with latest data\nfunction updateHistoryTable(history) {\n  if (!history || !history.length) return;\n\n  const historyTbody = document.querySelector('#history-table tbody');\n  if (!historyTbody) return;\n\n  // Show all entries (unlimited history)\n  const latestEntries = history.slice().reverse();\n\n  historyTbody.innerHTML = latestEntries.map(entry => `\n    <tr>\n      <td class=\"px-4 py-3 text-sm\">${entry.timestamp}</td>\n      <td class=\"px-4 py-3 text-sm\">${entry.username}</td>\n      <td class=\"px-4 py-3 text-sm\">${entry.action.replace('_', ' ')}</td>\n      <td class=\"px-4 py-3 text-sm\">${entry.zone || '-'}</td>\n      <td class=\"px-4 py-3 text-sm\">${\n        entry.action === 'completed_work' ? 'Work cycle completed' :\n        entry.action === 'completed_rest' ? 'Rest cycle completed' :\n        entry.action === 'start_rest' ? 'Started rest period' :\n        entry.action === 'early_completion' ? 'Cycle ended early by user' : ''\n      }</td>\n    </tr>\n  `).join('');\n}\n\n// Admin functions for WBGT system control\nfunction confirmCutOff() {\n  const isCutOffActive = document.querySelector('button[onclick=\"confirmCutOff()\"]').textContent.includes('Deactivate');\n\n  if (isCutOffActive) {\n    if (confirm('Are you sure you want to deactivate cut-off mode?')) {\n      setCutOffMode(false);\n    }\n  } else {\n    if (confirm('Are you sure you want to activate cut-off mode? This will immediately stop all activities.')) {\n      setCutOffMode(true);\n    }\n  }\n}\n\nfunction setCutOffMode(enable) {\n  fetch('/set_cut_off', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      enable: enable.toString()\n    })\n  })\n  .then(response => {\n    if (!response.ok) {\n      return response.json().then(data => {\n        throw new Error(data.error || 'Failed to set cut-off mode');\n      });\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log('Cut-off mode updated successfully:', data);\n    fetchSystemStatus(); // Refresh system status\n  })\n  .catch(error => {\n    console.error('Error setting cut-off mode:', error);\n    alert(`Error: ${error.message}`);\n  });\n}\n\nfunction updateSelectedUsers(zone) {\n  const checkboxes = document.querySelectorAll('.user-checkbox:checked');\n  if (checkboxes.length === 0) {\n    alert('Please select at least one trainer');\n    return;\n  }\n\n  const userIds = Array.from(checkboxes).map(cb => cb.value);\n\n  Promise.all(userIds.map(userId => {\n    return fetch('/set_zone_for_user', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      body: new URLSearchParams({\n        username: window.currentUser,\n        target_user: userId,\n        zone: zone\n      })\n    })\n    .then(response => {\n      if (!response.ok) {\n        return response.json().then(data => {\n          throw new Error(`Failed for ${userId}: ${data.error}`);\n        });\n      }\n      return response.json();\n    });\n  }))\n  .then(results => {\n    console.log('Updated zones for users:', results);\n    fetchSystemStatus(); // Refresh system status\n  })\n  .catch(error => {\n    console.error('Error updating users:', error);\n    alert(`Error: ${error.message}`);\n  });\n}\n\nfunction clearCommands() {\n  if (confirm('Are you sure you want to clear all pending commands?')) {\n    fetch('/clear_commands', {\n      method: 'POST'\n    })\n    .then(response => {\n      if (!response.ok) {\n        return response.json().then(data => {\n          throw new Error(data.error || 'Failed to clear commands');\n        });\n      }\n      return response.json();\n    })\n    .then(data => {\n      console.log('Commands cleared successfully:', data);\n      fetchSystemStatus(); // Refresh system status\n    })\n    .catch(error => {\n      console.error('Error clearing commands:', error);\n      alert(`Error: ${error.message}`);\n    });\n  }\n}\n\nfunction resetLogs() {\n  if (confirm('Are you sure you want to reset all user logs? This cannot be undone.')) {\n    fetch('/reset_logs', {\n      method: 'POST'\n    })\n    .then(response => {\n      if (!response.ok) {\n        return response.json().then(data => {\n          throw new Error(data.error || 'Failed to reset logs');\n        });\n      }\n      return response.json();\n    })\n    .then(data => {\n      console.log('Logs reset successfully:', data);\n      location.reload(); // Reload the page to reflect changes\n    })\n    .catch(error => {\n      console.error('Error resetting logs:', error);\n      alert(`Error: ${error.message}`);\n    });\n  }\n}\n\n// Zone button control functions\nfunction disableZoneButtons() {\n  const zoneButtons = document.querySelector('.w-full.max-w-xs');\n  if (zoneButtons) {\n    zoneButtons.style.pointerEvents = 'none';\n    zoneButtons.style.opacity = '0.5';\n    console.log('Zone buttons disabled');\n  }\n}\n\nfunction enableZoneButtons() {\n  const zoneButtons = document.querySelector('.w-full.max-w-xs');\n  if (zoneButtons) {\n    zoneButtons.style.pointerEvents = '';\n    zoneButtons.style.opacity = '';\n    console.log('Zone buttons enabled');\n  }\n}\n\n// Check zone restrictions and update button states\nfunction checkZoneRestrictions() {\n  if (!window.currentUser) return;\n\n  fetch(`/get_user_state/${window.currentUser}`)\n    .then(response => response.json())\n    .then(data => {\n      const restrictions = {\n        systemCutOff: false,\n        mandatoryRest: null,\n        disabledByReminder: false,\n        disabledByPendingRest: data.pending_rest || false,\n        disabledByRest: data.status === 'resting',\n        workCompleted: data.work_completed || false,\n        pendingRest: data.pending_rest || false\n      };\n\n      // Check system status\n      fetch('/get_system_status')\n        .then(response => response.json())\n        .then(systemStatus => {\n          restrictions.systemCutOff = systemStatus.cut_off;\n          restrictions.mandatoryRest = systemStatus.cut_off_end_time;\n\n          const shouldDisable = restrictions.systemCutOff || \n                               restrictions.mandatoryRest || \n                               restrictions.disabledByRest ||\n                               restrictions.disabledByPendingRest ||\n                               (data.status === 'working');\n\n          if (shouldDisable) {\n            disableZoneButtons();\n            if (data.status === 'working') {\n              console.log('Zones disabled - work cycle active');\n            } else {\n              console.log('Zones kept disabled - restrictions still apply:', restrictions);\n            }\n          } else {\n            enableZoneButtons();\n            console.log('Zones enabled - no restrictions');\n          }\n        })\n        .catch(error => console.error('Error checking system status:', error));\n    })\n    .catch(error => console.error('Error checking user state:', error));\n}\n\n// Universal rest start function that can be called from notifications\nwindow.startRest = function(zone) {\n  console.log('Starting rest cycle for zone:', zone);\n  \n  if (!window.currentUser) {\n    console.error('Cannot start rest - no current user');\n    return;\n  }\n\n  fetch('/start_rest', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n    body: new URLSearchParams({\n      username: window.currentUser,\n      zone: zone\n    })\n  })\n  .then(response => {\n    if (!response.ok) {\n      return response.json().then(data => {\n        throw new Error(data.error || 'Failed to start rest cycle');\n      });\n    }\n    return response.json();\n  })\n  .then(data => {\n    console.log('Rest cycle started successfully:', data);\n    \n    // Update dashboard immediately\n    updateDashboard();\n    \n    // Check zone restrictions\n    checkZoneRestrictions();\n    \n    // Mark as notified in enhanced notification system\n    if (window.enhancedNotificationManager) {\n      window.enhancedNotificationManager.markAsNotified();\n    }\n  })\n  .catch(error => {\n    console.error('Error starting rest cycle:', error);\n    alert(`Error starting rest cycle: ${error.message}`);\n  });\n};\n\n// Initial status check at page load\ndocument.addEventListener('DOMContentLoaded', function() {\n  zoneButtonsContainer = document.querySelector('.w-full.max-w-xs');\n  fetchSystemStatus();\n\n  // Check zone restrictions periodically\n  setInterval(checkZoneRestrictions, 2000);\n});\n","size_bytes":25966},"static/production-notifications.js":{"content":"// Production notification system for Chrome on Render deployment\n// This system works independently of service workers and handles page refresh scenarios\n\nclass ProductionNotificationManager {\n    constructor() {\n        this.isSupported = 'Notification' in window;\n        this.refreshInterval = null;\n        this.lastWorkCompletionCheck = null;\n        console.log('Production Notification Manager initialized');\n    }\n\n    // Initialize automatic refresh-based notification checking\n    initialize(username) {\n        console.log('Initializing production notifications for:', username);\n        \n        if (!this.isSupported) {\n            console.log('Notifications not supported in this browser');\n            return false;\n        }\n\n        // Request permission if not already granted\n        this.requestPermission().then(granted => {\n            if (granted) {\n                console.log('Production notifications permission granted');\n                this.startPeriodicCheck(username);\n            } else {\n                console.log('Production notifications permission denied');\n            }\n        });\n\n        return true;\n    }\n\n    async requestPermission() {\n        if (Notification.permission === 'granted') {\n            return true;\n        }\n\n        if (Notification.permission === 'denied') {\n            return false;\n        }\n\n        try {\n            const permission = await Notification.requestPermission();\n            return permission === 'granted';\n        } catch (error) {\n            console.error('Error requesting notification permission:', error);\n            return false;\n        }\n    }\n\n    // Start periodic checking for work completion (every 5 seconds)\n    startPeriodicCheck(username) {\n        console.log('Starting periodic work completion check for production notifications');\n        \n        // Clear any existing interval\n        if (this.refreshInterval) {\n            clearInterval(this.refreshInterval);\n        }\n\n        // Check immediately\n        this.checkWorkCompletion(username);\n\n        // Then check every 5 seconds\n        this.refreshInterval = setInterval(() => {\n            this.checkWorkCompletion(username);\n        }, 5000);\n    }\n\n    checkWorkCompletion(username) {\n        fetch(`/get_user_state/${username}`)\n            .then(response => response.json())\n            .then(data => {\n                if (data.work_completed && data.pending_rest) {\n                    const workEndTime = new Date(data.end_time).getTime();\n                    \n                    // Only show notification if this is a new work completion\n                    if (this.lastWorkCompletionCheck !== workEndTime) {\n                        console.log('New work completion detected via periodic check');\n                        this.lastWorkCompletionCheck = workEndTime;\n                        this.showWorkCompletionNotification(data);\n                    }\n                }\n            })\n            .catch(error => {\n                console.error('Error checking work completion:', error);\n            });\n    }\n\n    showWorkCompletionNotification(data) {\n        console.log('Showing production work completion notification:', data);\n\n        if (Notification.permission !== 'granted') {\n            console.log('Cannot show notification - permission not granted');\n            return;\n        }\n\n        const restTime = this.getRestTimeForZone(data.zone);\n        const timeUnit = data.zone === 'test' ? 'second' : 'minute';\n\n        try {\n            const notification = new Notification('🚨 Work Cycle Complete!', {\n                body: `Your ${data.zone?.toUpperCase() || 'WORK'} zone work cycle has ended. Start your ${restTime} ${timeUnit} rest cycle now!`,\n                icon: '/static/icon-192.png',\n                tag: 'wbgt-production-' + Date.now(),\n                requireInteraction: true,\n                silent: false\n            });\n\n            notification.onclick = () => {\n                console.log('Production notification clicked');\n                window.focus();\n                notification.close();\n                \n                // Focus on the dashboard if not already there\n                if (!window.location.pathname.includes('/dashboard')) {\n                    window.location.href = '/dashboard';\n                }\n            };\n\n            notification.onshow = () => {\n                console.log('Production notification shown successfully');\n            };\n\n            notification.onerror = (error) => {\n                console.error('Production notification error:', error);\n            };\n\n            // Auto-close after 30 seconds and show reminder\n            setTimeout(() => {\n                if (notification) {\n                    notification.close();\n                    this.showReminderNotification(data, restTime, timeUnit);\n                }\n            }, 30000);\n\n        } catch (error) {\n            console.error('Failed to show production notification:', error);\n        }\n    }\n\n    showReminderNotification(data, restTime, timeUnit) {\n        console.log('Showing reminder notification');\n\n        if (Notification.permission !== 'granted') {\n            return;\n        }\n\n        try {\n            const reminderNotification = new Notification('⚠️ Rest Reminder', {\n                body: `You still need to start your ${restTime} ${timeUnit} rest cycle. Don't forget!`,\n                icon: '/static/icon-192.png',\n                tag: 'wbgt-reminder-' + Date.now(),\n                requireInteraction: true,\n                silent: false\n            });\n\n            reminderNotification.onclick = () => {\n                window.focus();\n                reminderNotification.close();\n            };\n\n        } catch (error) {\n            console.error('Failed to show reminder notification:', error);\n        }\n    }\n\n    getRestTimeForZone(zone) {\n        const restTimes = {\n            'white': 15,\n            'green': 15,\n            'yellow': 15,\n            'red': 30,\n            'black': 30,\n            'test': 10\n        };\n        return restTimes[zone] || 15;\n    }\n\n    // Stop periodic checking\n    stop() {\n        if (this.refreshInterval) {\n            clearInterval(this.refreshInterval);\n            this.refreshInterval = null;\n        }\n        console.log('Production notification checking stopped');\n    }\n\n    // Show immediate test notification\n    test() {\n        console.log('Testing production notification');\n        \n        if (Notification.permission !== 'granted') {\n            console.log('Cannot test - permission not granted');\n            return false;\n        }\n\n        try {\n            const testNotification = new Notification('Test Notification', {\n                body: 'Production notification system is working correctly!',\n                icon: '/static/icon-192.png',\n                tag: 'wbgt-test-notification',\n                requireInteraction: true\n            });\n\n            testNotification.onclick = () => {\n                window.focus();\n                testNotification.close();\n            };\n\n            console.log('Test notification shown');\n            return true;\n        } catch (error) {\n            console.error('Test notification failed:', error);\n            return false;\n        }\n    }\n}\n\n// Global production notification manager\nlet productionNotificationManager = null;\n\n// Initialize production notifications\nfunction initializeProductionNotifications(username) {\n    console.log('Initializing production notification system');\n    \n    if (!productionNotificationManager) {\n        productionNotificationManager = new ProductionNotificationManager();\n    }\n    \n    return productionNotificationManager.initialize(username);\n}\n\n// Test production notification\nfunction testProductionNotification() {\n    if (productionNotificationManager) {\n        return productionNotificationManager.test();\n    }\n    console.error('Production notification manager not initialized');\n    return false;\n}\n\n// Stop production notifications\nfunction stopProductionNotifications() {\n    if (productionNotificationManager) {\n        productionNotificationManager.stop();\n    }\n}","size_bytes":8209},"static/simple-refresh-notifications.js":{"content":"// Simple Refresh-Based Notification System\n// ONLY notification system that works reliably on Chrome and iOS Safari on Render platform\n// No automatic popups - only works when user clicks refresh button\n\nclass SimpleRefreshNotifications {\n    constructor() {\n        this.hasShownNotification = false;\n        this.isProcessing = false;\n        console.log('Simple refresh notification system initialized');\n    }\n\n    // Main function called when user clicks refresh button\n    async checkAndShowNotifications(username) {\n        if (this.isProcessing) {\n            console.log('Already processing notification check');\n            return;\n        }\n\n        this.isProcessing = true;\n        console.log('Checking for work completion notifications for:', username);\n\n        try {\n            const response = await fetch(`/get_user_state/${username}`);\n            const userData = await response.json();\n            \n            console.log('User state retrieved:', userData);\n\n            // Check if user has completed work and needs rest\n            if (userData.work_completed && userData.pending_rest && userData.zone) {\n                console.log('Work completion detected - showing notification');\n                this.showWorkCompletionNotification(userData, username);\n            } else {\n                console.log('No work completion notifications needed');\n                this.showNoNotificationMessage();\n            }\n        } catch (error) {\n            console.error('Error checking user state:', error);\n            alert('Error checking for notifications. Please try again.');\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    showWorkCompletionNotification(userData, username) {\n        const restTime = this.getRestTimeForZone(userData.zone);\n        const timeUnit = userData.zone === 'test' ? 'second' : 'minute';\n        \n        console.log('Showing work completion notification for zone:', userData.zone);\n\n        // Show multiple notification methods for maximum reliability\n        this.showBrowserNotification(userData, restTime, timeUnit);\n        this.showModalNotification(userData, restTime, timeUnit, username);\n        this.showVisualAlert(userData, restTime, timeUnit);\n        this.playAudioAlert();\n        this.triggerVibration();\n\n        this.hasShownNotification = true;\n    }\n\n    showBrowserNotification(userData, restTime, timeUnit) {\n        if ('Notification' in window) {\n            if (Notification.permission === 'granted') {\n                try {\n                    const notification = new Notification('🚨 Work Cycle Complete!', {\n                        body: `Your ${userData.zone.toUpperCase()} work cycle ended. Start your ${restTime} ${timeUnit} rest now!`,\n                        icon: '/static/icon-192.png',\n                        requireInteraction: true,\n                        tag: 'work-complete',\n                        silent: false\n                    });\n\n                    notification.onclick = () => {\n                        window.focus();\n                        notification.close();\n                    };\n\n                    console.log('Browser notification shown');\n                } catch (error) {\n                    console.log('Browser notification failed:', error);\n                }\n            } else if (Notification.permission === 'default') {\n                Notification.requestPermission().then(permission => {\n                    if (permission === 'granted') {\n                        this.showBrowserNotification(userData, restTime, timeUnit);\n                    }\n                });\n            }\n        }\n    }\n\n    showModalNotification(userData, restTime, timeUnit, username) {\n        // Create or update the modal\n        let modal = document.getElementById('refresh-notification-modal');\n        if (!modal) {\n            modal = this.createNotificationModal();\n        }\n\n        // Update modal content\n        document.getElementById('refresh-modal-title').textContent = '🚨 Work Cycle Complete!';\n        document.getElementById('refresh-modal-message').textContent = \n            `Your ${userData.zone.toUpperCase()} work cycle has ended. You must start your ${restTime} ${timeUnit} rest cycle now!`;\n\n        // Show modal\n        modal.classList.remove('hidden');\n        modal.style.display = 'flex';\n\n        // Set up event listeners\n        this.setupModalEventListeners(userData, username);\n\n        console.log('Modal notification shown');\n    }\n\n    createNotificationModal() {\n        const modalHTML = `\n            <div id=\"refresh-notification-modal\" class=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden\">\n                <div class=\"bg-white rounded-lg p-6 max-w-md mx-4 shadow-xl border-4 border-red-500\">\n                    <div class=\"text-center\">\n                        <div class=\"text-4xl mb-4\">🚨</div>\n                        <h3 id=\"refresh-modal-title\" class=\"text-xl font-bold text-red-600 mb-4\"></h3>\n                        <p id=\"refresh-modal-message\" class=\"text-gray-700 mb-6\"></p>\n                        <div class=\"flex flex-col gap-3\">\n                            <button id=\"refresh-start-rest\" class=\"bg-green-600 text-white px-6 py-3 rounded font-bold hover:bg-green-700 transition\">\n                                Start Rest Cycle\n                            </button>\n                            <button id=\"refresh-dismiss\" class=\"bg-gray-600 text-white px-6 py-2 rounded hover:bg-gray-700 transition\">\n                                Dismiss\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        `;\n\n        document.body.insertAdjacentHTML('beforeend', modalHTML);\n        return document.getElementById('refresh-notification-modal');\n    }\n\n    setupModalEventListeners(userData, username) {\n        const startRestBtn = document.getElementById('refresh-start-rest');\n        const dismissBtn = document.getElementById('refresh-dismiss');\n\n        // Remove existing listeners\n        startRestBtn.replaceWith(startRestBtn.cloneNode(true));\n        dismissBtn.replaceWith(dismissBtn.cloneNode(true));\n\n        // Add new listeners\n        document.getElementById('refresh-start-rest').addEventListener('click', () => {\n            this.startRestCycle(username);\n        });\n\n        document.getElementById('refresh-dismiss').addEventListener('click', () => {\n            this.dismissNotification();\n        });\n    }\n\n    async startRestCycle(username) {\n        console.log('Starting rest cycle for:', username);\n\n        try {\n            const response = await fetch('/start_rest', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded',\n                },\n                body: new URLSearchParams({\n                    username: username\n                })\n            });\n\n            const data = await response.json();\n\n            if (data.success) {\n                console.log('Rest cycle started successfully');\n                this.dismissNotification();\n                // Refresh page to update dashboard\n                setTimeout(() => {\n                    window.location.reload();\n                }, 500);\n            } else {\n                console.error('Failed to start rest cycle:', data.error);\n                alert('Failed to start rest cycle: ' + (data.error || 'Unknown error'));\n            }\n        } catch (error) {\n            console.error('Error starting rest cycle:', error);\n            alert('Error starting rest cycle. Please try again.');\n        }\n    }\n\n    dismissNotification() {\n        const modal = document.getElementById('refresh-notification-modal');\n        if (modal) {\n            modal.classList.add('hidden');\n            modal.style.display = 'none';\n        }\n        console.log('Notification dismissed');\n    }\n\n    showVisualAlert(userData, restTime, timeUnit) {\n        // Create visual alert bar at top of screen\n        let alertBar = document.getElementById('refresh-visual-alert');\n        if (!alertBar) {\n            alertBar = document.createElement('div');\n            alertBar.id = 'refresh-visual-alert';\n            alertBar.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                background: linear-gradient(45deg, #ef4444, #dc2626);\n                color: white;\n                text-align: center;\n                padding: 15px;\n                font-weight: bold;\n                z-index: 1000;\n                animation: pulse 2s infinite;\n                border-bottom: 3px solid #991b1b;\n            `;\n            document.body.appendChild(alertBar);\n        }\n\n        alertBar.textContent = `🚨 WORK COMPLETE! Start your ${restTime} ${timeUnit} rest cycle now! 🚨`;\n        alertBar.style.display = 'block';\n\n        // Auto-hide after 10 seconds\n        setTimeout(() => {\n            if (alertBar) {\n                alertBar.style.display = 'none';\n            }\n        }, 10000);\n\n        console.log('Visual alert shown');\n    }\n\n    playAudioAlert() {\n        try {\n            // Create audio context for mobile compatibility\n            const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            \n            if (audioContext.state === 'suspended') {\n                audioContext.resume();\n            }\n\n            // Create beep sound\n            const oscillator = audioContext.createOscillator();\n            const gainNode = audioContext.createGain();\n\n            oscillator.connect(gainNode);\n            gainNode.connect(audioContext.destination);\n\n            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\n            oscillator.type = 'sine';\n\n            gainNode.gain.setValueAtTime(0, audioContext.currentTime);\n            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.1);\n            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);\n\n            oscillator.start(audioContext.currentTime);\n            oscillator.stop(audioContext.currentTime + 1);\n\n            console.log('Audio alert played');\n        } catch (error) {\n            console.log('Audio alert failed:', error);\n        }\n    }\n\n    triggerVibration() {\n        if ('vibrate' in navigator) {\n            navigator.vibrate([500, 200, 500, 200, 500]);\n            console.log('Vibration triggered');\n        }\n    }\n\n    showNoNotificationMessage() {\n        // Show brief message that no notifications are pending\n        let messageDiv = document.getElementById('refresh-status-message');\n        if (!messageDiv) {\n            messageDiv = document.createElement('div');\n            messageDiv.id = 'refresh-status-message';\n            messageDiv.style.cssText = `\n                position: fixed;\n                top: 50%;\n                left: 50%;\n                transform: translate(-50%, -50%);\n                background: #10b981;\n                color: white;\n                padding: 20px;\n                border-radius: 8px;\n                font-weight: bold;\n                z-index: 1000;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n            `;\n            document.body.appendChild(messageDiv);\n        }\n\n        messageDiv.textContent = '✓ No work completion notifications';\n        messageDiv.style.display = 'block';\n\n        // Auto-hide after 2 seconds\n        setTimeout(() => {\n            if (messageDiv) {\n                messageDiv.style.display = 'none';\n            }\n        }, 2000);\n\n        console.log('No notification message shown');\n    }\n\n    getRestTimeForZone(zone) {\n        const restTimes = {\n            'white': 15,\n            'green': 15,\n            'yellow': 15,\n            'red': 30,\n            'black': 30,\n            'test': 10,\n            'cutoff': 30\n        };\n        return restTimes[zone] || 15;\n    }\n}\n\n// Initialize the notification system\nconst simpleRefreshNotifications = new SimpleRefreshNotifications();\n\n\nconsole.log('Simple refresh notifications loaded');","size_bytes":12239},"static/sw.js":{"content":"// Enhanced WBGT Service Worker with Background Sync and Persistent Notifications\nconst CACHE_NAME = 'wbgt-v2';\nconst urlsToCache = [\n  '/',\n  '/static/main.js',\n  '/static/icon-192.png'\n];\n\n// Store for tracking work completion states\nlet workCompletionStates = new Map();\nlet activeUsernames = new Set();\nlet checkInterval = null;\n\n// Install event\nself.addEventListener('install', function(event) {\n  console.log('[SW] Installing enhanced WBGT service worker...');\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(function(cache) {\n        return cache.addAll(urlsToCache);\n      })\n      .then(() => {\n        console.log('[SW] Cache populated successfully');\n        return self.skipWaiting(); // Activate immediately\n      })\n  );\n});\n\n// Activate event\nself.addEventListener('activate', function(event) {\n  console.log('[SW] Activating enhanced WBGT service worker...');\n  event.waitUntil(\n    caches.keys().then(function(cacheNames) {\n      return Promise.all(\n        cacheNames.map(function(cacheName) {\n          if (cacheName !== CACHE_NAME) {\n            console.log('[SW] Deleting old cache:', cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    }).then(() => {\n      console.log('[SW] Service worker activated and ready');\n      return self.clients.claim(); // Take control immediately\n    })\n  );\n});\n\n// Fetch event with caching\nself.addEventListener('fetch', function(event) {\n  event.respondWith(\n    caches.match(event.request)\n      .then(function(response) {\n        return response || fetch(event.request);\n      })\n  );\n});\n\n// Background sync for work completion checking\nself.addEventListener('sync', function(event) {\n  console.log('[SW] Background sync triggered:', event.tag);\n  \n  if (event.tag === 'wbgt-work-check') {\n    event.waitUntil(checkAllUsersWorkCompletion());\n  }\n});\n\n// Message handling from main thread\nself.addEventListener('message', function(event) {\n  console.log('[SW] Message received:', event.data);\n  \n  const { type, data } = event.data;\n  \n  switch (type) {\n    case 'START_MONITORING':\n      startMonitoring(data.username);\n      break;\n    case 'STOP_MONITORING':\n      stopMonitoring(data.username);\n      break;\n    case 'CHECK_USER':\n      checkUserWorkCompletion(data.username);\n      break;\n    case 'MARK_NOTIFIED':\n      markUserNotified(data.username);\n      break;\n  }\n});\n\n// Start monitoring a user\nfunction startMonitoring(username) {\n  console.log('[SW] Starting monitoring for:', username);\n  activeUsernames.add(username);\n  \n  // Initialize state if not exists\n  if (!workCompletionStates.has(username)) {\n    workCompletionStates.set(username, {\n      lastCheckTime: Date.now(),\n      workCompleted: false,\n      pendingRest: false,\n      zone: null,\n      notificationShown: false\n    });\n  }\n  \n  // Start periodic checking if not already running\n  if (!checkInterval) {\n    startPeriodicCheck();\n  }\n}\n\n// Stop monitoring a user\nfunction stopMonitoring(username) {\n  console.log('[SW] Stopping monitoring for:', username);\n  activeUsernames.delete(username);\n  workCompletionStates.delete(username);\n  \n  // Stop periodic checking if no active users\n  if (activeUsernames.size === 0 && checkInterval) {\n    clearInterval(checkInterval);\n    checkInterval = null;\n    console.log('[SW] Stopped periodic checking - no active users');\n  }\n}\n\n// Start periodic checking every 3 seconds\nfunction startPeriodicCheck() {\n  if (checkInterval) {\n    clearInterval(checkInterval);\n  }\n  \n  console.log('[SW] Starting periodic work completion check');\n  checkInterval = setInterval(() => {\n    if (activeUsernames.size > 0) {\n      checkAllUsersWorkCompletion();\n    }\n  }, 3000); // Check every 3 seconds for responsiveness\n}\n\n// Check all active users for work completion\nasync function checkAllUsersWorkCompletion() {\n  const promises = Array.from(activeUsernames).map(username => \n    checkUserWorkCompletion(username)\n  );\n  \n  await Promise.all(promises);\n}\n\n// Check individual user for work completion\nasync function checkUserWorkCompletion(username) {\n  try {\n    const response = await fetch(`/get_user_state/${username}`);\n    const userData = await response.json();\n    \n    const currentState = workCompletionStates.get(username) || {};\n    const hasWorkCompleted = userData.work_completed && userData.pending_rest && userData.zone;\n    \n    // Check if this is a new work completion (transition from not completed to completed)\n    const isNewCompletion = hasWorkCompleted && \n      (!currentState.workCompleted || currentState.zone !== userData.zone || currentState.notificationShown === false);\n    \n    // Update state\n    workCompletionStates.set(username, {\n      lastCheckTime: Date.now(),\n      workCompleted: userData.work_completed,\n      pendingRest: userData.pending_rest,\n      zone: userData.zone,\n      notificationShown: isNewCompletion ? false : currentState.notificationShown\n    });\n    \n    // Show notification if new completion detected\n    if (isNewCompletion) {\n      await showWorkCompletionNotification(username, userData);\n      \n      // Mark as notified\n      const updatedState = workCompletionStates.get(username);\n      updatedState.notificationShown = true;\n      workCompletionStates.set(username, updatedState);\n    }\n    \n  } catch (error) {\n    console.error('[SW] Error checking user state for', username, ':', error);\n  }\n}\n\n// Show work completion notification\nasync function showWorkCompletionNotification(username, userData) {\n  const restTime = getRestTimeForZone(userData.zone);\n  const timeUnit = userData.zone === 'test' ? 'second' : 'minute';\n  \n  console.log('[SW] Showing work completion notification for:', username, 'zone:', userData.zone);\n  \n  // Create persistent notification\n  const notificationOptions = {\n    body: `Your ${userData.zone.toUpperCase()} work cycle has ended. Start your ${restTime} ${timeUnit} rest cycle now!`,\n    icon: '/static/icon-192.png',\n    badge: '/static/icon-192.png',\n    tag: `work-complete-${username}-${userData.zone}`,\n    requireInteraction: true,\n    persistent: true,\n    renotify: true,\n    vibrate: [200, 100, 200, 100, 200],\n    data: {\n      username: username,\n      zone: userData.zone,\n      restTime: restTime,\n      timeUnit: timeUnit,\n      timestamp: Date.now()\n    },\n    actions: [\n      {\n        action: 'start-rest',\n        title: 'Start Rest Cycle',\n        icon: '/static/icon-192.png'\n      },\n      {\n        action: 'dismiss',\n        title: 'Dismiss',\n        icon: '/static/icon-192.png'\n      }\n    ]\n  };\n  \n  await self.registration.showNotification(\n    `🚨 Work Complete - ${userData.zone.toUpperCase()} Zone`,\n    notificationOptions\n  );\n  \n  // Also send message to any open clients\n  const clients = await self.clients.matchAll();\n  clients.forEach(client => {\n    client.postMessage({\n      type: 'WORK_COMPLETION_DETECTED',\n      data: {\n        username: username,\n        zone: userData.zone,\n        restTime: restTime,\n        timeUnit: timeUnit\n      }\n    });\n  });\n}\n\n// Get rest time for zone (matches server-side logic)\nfunction getRestTimeForZone(zone) {\n  const WBGT_ZONES = {\n    \"white\": { \"work\": 60, \"rest\": 15 },\n    \"green\": { \"work\": 45, \"rest\": 15 },\n    \"yellow\": { \"work\": 30, \"rest\": 15 },\n    \"red\": { \"work\": 30, \"rest\": 30 },\n    \"black\": { \"work\": 15, \"rest\": 30 },\n    \"test\": { \"work\": 7/60, \"rest\": 10 },\n    \"cut-off\": { \"work\": 0, \"rest\": 30 }\n  };\n  \n  return WBGT_ZONES[zone]?.rest || 15;\n}\n\n// Mark user as notified\nfunction markUserNotified(username) {\n  const state = workCompletionStates.get(username);\n  if (state) {\n    state.notificationShown = true;\n    workCompletionStates.set(username, state);\n    console.log('[SW] Marked user as notified:', username);\n  }\n}\n\n// Handle notification click\nself.addEventListener('notificationclick', function(event) {\n  console.log('[SW] Notification clicked:', event.notification.tag);\n  \n  event.notification.close();\n  \n  const { username, zone } = event.notification.data;\n  \n  if (event.action === 'start-rest') {\n    // Open the dashboard and trigger rest start\n    event.waitUntil(\n      self.clients.matchAll().then(clients => {\n        let clientToFocus = null;\n        \n        // Find existing client\n        for (let client of clients) {\n          if (client.url.includes('/dashboard')) {\n            clientToFocus = client;\n            break;\n          }\n        }\n        \n        if (clientToFocus) {\n          // Focus existing client and send message\n          clientToFocus.focus();\n          clientToFocus.postMessage({\n            type: 'START_REST_FROM_NOTIFICATION',\n            data: { username, zone }\n          });\n        } else {\n          // Open new client\n          self.clients.openWindow('/dashboard').then(client => {\n            // Send message after a delay to ensure page is loaded\n            setTimeout(() => {\n              client.postMessage({\n                type: 'START_REST_FROM_NOTIFICATION',\n                data: { username, zone }\n              });\n            }, 1000);\n          });\n        }\n      })\n    );\n  } else {\n    // Just open/focus the dashboard\n    event.waitUntil(\n      self.clients.matchAll().then(clients => {\n        if (clients.length > 0) {\n          clients[0].focus();\n        } else {\n          self.clients.openWindow('/dashboard');\n        }\n      })\n    );\n  }\n  \n  // Mark user as notified\n  markUserNotified(username);\n});","size_bytes":9436},"static/work-notifications.js":{"content":"// Enhanced work cycle completion notifications with progressive reminders\nlet notificationPermission = null;\nlet restReminderInterval = null;\nlet restReminderTimeout = null;\nlet audioContextInitialized = false;\nlet isMobile = false;\n\n// Detect mobile browser\nfunction detectMobile() {\n    const userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    isMobile = /android|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n    return isMobile;\n}\n\n// Enhanced work cycle completion notifications with progressive reminders\nclass WorkCompletionModal {\n    constructor() {\n        this.dismissTimeout = null;\n        this.progressiveReminderInterval = null;\n        this.isDismissed = false;\n        this.reminderCount = 0;\n        detectMobile(); // Initialize mobile detection\n    }\n\n    showWorkCompletionModal(data) {\n        console.log('Showing work completion modal:', data);\n        \n        // Clear any existing timers\n        this.clearAllNotifications();\n        \n        // Create and show the modal\n        const modal = document.getElementById('work-complete-modal');\n        if (modal) {\n            // Update modal content\n            const modalTitle = document.getElementById('modal-title');\n            const modalMessage = document.getElementById('modal-message');\n            \n            if (modalTitle) modalTitle.textContent = data.title || 'Work Cycle Complete!';\n            if (modalMessage) modalMessage.textContent = data.message || 'Great job! Time to start your rest cycle.';\n            \n            // Show the modal\n            modal.classList.remove('hidden');\n            \n            // Set up event listeners\n            this.setupModalEventListeners(data);\n            \n            // Play alert sound and vibration for mobile\n            this.playAlertSound();\n            if (isMobile && 'vibrate' in navigator) {\n                navigator.vibrate([800, 300, 800, 300, 800, 300, 1000]);\n            }\n        }\n    }\n\n    setupModalEventListeners(data) {\n        const startRestBtn = document.getElementById('start-rest-btn');\n        const dismissBtn = document.getElementById('dismiss-modal-btn');\n        \n        if (startRestBtn) {\n            startRestBtn.onclick = () => {\n                console.log('Start rest button clicked');\n                this.handleStartRest();\n            };\n        }\n        \n        if (dismissBtn) {\n            dismissBtn.onclick = () => {\n                console.log('Dismiss button clicked');\n                this.handleDismiss(data);\n            };\n        }\n    }\n\n    handleStartRest() {\n        // Clear all notifications and start rest cycle\n        this.clearAllNotifications();\n        \n        // Hide modal\n        const modal = document.getElementById('work-complete-modal');\n        if (modal) {\n            modal.classList.add('hidden');\n        }\n        \n        // Call the server to start rest cycle\n        fetch('/start_rest', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            body: new URLSearchParams({\n                username: window.currentUser\n            })\n        })\n        .then(response => response.json())\n        .then(data => {\n            if (data.success) {\n                console.log('Rest cycle started successfully');\n                // Update dashboard\n                if (typeof window.updateDashboard === 'function') {\n                    window.updateDashboard();\n                }\n            } else {\n                console.error('Failed to start rest cycle:', data.error);\n                alert('Failed to start rest cycle: ' + (data.error || 'Unknown error'));\n            }\n        })\n        .catch(error => {\n            console.error('Error starting rest cycle:', error);\n            alert('Error starting rest cycle. Please try again.');\n        });\n    }\n\n    handleDismiss(data) {\n        console.log('Handling dismiss with data:', data);\n        \n        // Hide modal immediately\n        const modal = document.getElementById('work-complete-modal');\n        if (modal) {\n            modal.classList.add('hidden');\n        }\n        \n        // Mark as dismissed and store state\n        this.isDismissed = true;\n        this.reminderCount = 0;\n        \n        // Store dismissal state in localStorage with timestamps for progressive reminders\n        const dismissedState = {\n            username: data.username || window.currentUser,\n            zone: data.zone,\n            rest_time: data.rest_duration || this.getCorrectRestTime(data.zone),\n            dismissedAt: Date.now(),\n            reminderStartTime: Date.now() + 5000, // First reminder after 5 seconds\n            action: 'work_cycle_completed'\n        };\n        \n        localStorage.setItem('workCompletionDismissed', JSON.stringify(dismissedState));\n        \n        console.log('Work completion dismissed, progressive reminders will start in 5 seconds');\n        \n        // Disable zone buttons while in reminder state\n        this.disableZoneButtons();\n        \n        // Start the progressive reminder system\n        this.startProgressiveReminders(dismissedState);\n    }\n\n    startProgressiveReminders(dismissedState) {\n        console.log('Starting progressive reminder system with state:', dismissedState);\n        \n        // Clear any existing reminders\n        if (this.dismissTimeout) {\n            clearTimeout(this.dismissTimeout);\n        }\n        if (this.progressiveReminderInterval) {\n            clearInterval(this.progressiveReminderInterval);\n        }\n        \n        // Set up first reminder after 5 seconds\n        this.dismissTimeout = setTimeout(() => {\n            console.log('Showing first progressive reminder (5 seconds after dismiss)');\n            this.showProgressiveReminder(dismissedState);\n            \n            // Then show reminders every 10 seconds\n            this.progressiveReminderInterval = setInterval(() => {\n                console.log('Showing continuous progressive reminder (every 10 seconds)');\n                this.showProgressiveReminder(dismissedState);\n            }, 10000);\n            \n        }, 5000);\n    }\n\n    showProgressiveReminder(data) {\n        this.reminderCount++;\n        console.log(`Showing progressive reminder #${this.reminderCount} with data:`, data);\n        \n        // Show the modal again with reminder styling\n        const modal = document.getElementById('work-complete-modal');\n        if (modal) {\n            // Update modal content for reminder\n            const modalTitle = document.getElementById('modal-title');\n            const modalMessage = document.getElementById('modal-message');\n            \n            if (modalTitle) {\n                modalTitle.textContent = `Reminder #${this.reminderCount}: Start Your Rest!`;\n            }\n            if (modalMessage) {\n                modalMessage.textContent = `You dismissed this ${this.reminderCount} time(s). You need to start your rest cycle.`;\n            }\n            \n            // Show the modal\n            modal.classList.remove('hidden');\n            \n            // Set up event listeners again\n            this.setupModalEventListeners(data);\n            \n            // Play reminder sound and vibration\n            this.playAlertSound();\n            if (isMobile && 'vibrate' in navigator) {\n                navigator.vibrate([500, 200, 500, 200, 500]);\n            }\n        } else {\n            console.error('Could not find work-complete-modal element for progressive reminder');\n        }\n    }\n\n    playAlertSound() {\n        try {\n            // Create audio context if not exists\n            if (!window.audioContext) {\n                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n            }\n            \n            // Resume audio context if suspended (required for mobile)\n            if (window.audioContext.state === 'suspended') {\n                window.audioContext.resume();\n            }\n            \n            // Create oscillator for beep sound\n            const oscillator = window.audioContext.createOscillator();\n            const gainNode = window.audioContext.createGain();\n            \n            oscillator.connect(gainNode);\n            gainNode.connect(window.audioContext.destination);\n            \n            oscillator.frequency.setValueAtTime(800, window.audioContext.currentTime);\n            gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);\n            \n            oscillator.start(window.audioContext.currentTime);\n            oscillator.stop(window.audioContext.currentTime + 0.3);\n            \n        } catch (e) {\n            console.log('Could not play alert sound:', e);\n        }\n    }\n\n    disableZoneButtons() {\n        const zoneButtons = document.querySelector('.grid.grid-cols-1.sm\\\\:grid-cols-2.lg\\\\:grid-cols-3');\n        if (zoneButtons) {\n            zoneButtons.style.pointerEvents = 'none';\n            zoneButtons.style.opacity = '0.5';\n            zoneButtons.setAttribute('data-disabled-by-reminder', 'true');\n            console.log('Zone buttons disabled due to pending rest');\n        }\n    }\n\n    enableZoneButtons() {\n        const zoneButtons = document.querySelector('.grid.grid-cols-1.sm\\\\:grid-cols-2.lg\\\\:grid-cols-3');\n        if (zoneButtons) {\n            zoneButtons.style.pointerEvents = '';\n            zoneButtons.style.opacity = '';\n            zoneButtons.removeAttribute('data-disabled-by-reminder');\n            console.log('Zone buttons enabled');\n        }\n    }\n\n    clearAllNotifications() {\n        console.log('Clearing all work completion notifications');\n        \n        // Clear timers\n        if (this.dismissTimeout) {\n            clearTimeout(this.dismissTimeout);\n            this.dismissTimeout = null;\n        }\n        if (this.progressiveReminderInterval) {\n            clearInterval(this.progressiveReminderInterval);\n            this.progressiveReminderInterval = null;\n        }\n        \n        // Reset state\n        this.isDismissed = false;\n        this.reminderCount = 0;\n        \n        // Clear localStorage\n        localStorage.removeItem('workCompletionDismissed');\n        \n        // Clear Chrome reminders if available\n        if (typeof clearChromeReminders === 'function') {\n            clearChromeReminders();\n        }\n        \n        // Re-enable zone buttons\n        this.enableZoneButtons();\n    }\n\n    getCorrectRestTime(zone) {\n        const restTimes = {\n            'white': 15,\n            'green': 15, \n            'yellow': 15,\n            'red': 30,\n            'black': 30,\n            'test': 10  // 10 seconds for test zone\n        };\n        return restTimes[zone] || 15;\n    }\n\n    // ENHANCED: Immediate work completion check for page refresh scenarios\n    performImmediateWorkCompletionCheck() {\n        console.log('Performing immediate work completion check after page refresh');\n        \n        fetch(`/get_user_state/${window.currentUser}`)\n            .then(response => response.json())\n            .then(data => {\n                console.log('Immediate check - user state:', data);\n                \n                if (data.work_completed && data.pending_rest) {\n                    console.log('FOUND PENDING WORK COMPLETION - Auto-showing modal after page refresh');\n                    \n                    // Use most stringent zone for rest calculation, fallback to current zone\n                    const zoneForRest = data.most_stringent_zone || data.zone;\n                    const restTime = this.getCorrectRestTime(zoneForRest);\n                    console.log(`REST CALCULATION: Current zone: ${data.zone}, Most stringent: ${data.most_stringent_zone}, Using: ${zoneForRest}, Rest time: ${restTime}`);\n                    \n                    // Show modal immediately with enhanced visibility\n                    this.showWorkCompletionModal({\n                        title: '⚠️ WORK CYCLE COMPLETE! ⚠️',\n                        message: `Your work cycle has ended. Time to start rest cycle!`,\n                        username: window.currentUser,\n                        zone: data.zone,\n                        most_stringent_zone: zoneForRest,\n                        rest_duration: restTime\n                    });\n                    \n                    // Disable zone buttons immediately to prevent new work cycles\n                    this.disableZoneButtons();\n                    \n                    // Play enhanced alert for page refresh scenarios\n                    this.playEnhancedAlertSound();\n                    \n                    // Enhanced mobile vibration for attention\n                    if (isMobile && 'vibrate' in navigator) {\n                        navigator.vibrate([1000, 300, 1000, 300, 1000, 300, 1500]);\n                    }\n\n                    // PRODUCTION FIX: Force browser notification as secondary measure\n                    this.showProductionNotification(data, restTime, zoneForRest);\n                }\n            })\n            .catch(error => {\n                console.error('Error in immediate work completion check:', error);\n            });\n    }\n\n    // Production notification system - works without service workers\n    showProductionNotification(data, restTime, zoneForRest) {\n        console.log('Showing production notification for Chrome on Render');\n        \n        if (!('Notification' in window)) {\n            console.log('Notification API not available');\n            return;\n        }\n\n        // Check permission and show notification immediately\n        if (Notification.permission === 'granted') {\n            try {\n                const notification = new Notification('Work Cycle Complete!', {\n                    body: `Your work cycle has ended. Time to start rest cycle!`,\n                    icon: '/static/icon-192.png',\n                    tag: 'wbgt-production-notification',\n                    requireInteraction: true,\n                    silent: false\n                });\n\n                notification.onclick = () => {\n                    window.focus();\n                    notification.close();\n                };\n\n                console.log('Production notification shown successfully');\n            } catch (error) {\n                console.error('Production notification failed:', error);\n            }\n        } else if (Notification.permission === 'default') {\n            // Request permission and then show notification\n            Notification.requestPermission().then(permission => {\n                if (permission === 'granted') {\n                    this.showProductionNotification(data, restTime);\n                }\n            });\n        }\n    }\n\n    // ENHANCED: Enhanced alert sound for critical notifications  \n    playEnhancedAlertSound() {\n        try {\n            // Play multiple alert tones for better attention\n            this.playAlertSound();\n            \n            setTimeout(() => {\n                this.playAlertSound();\n            }, 500);\n            \n            setTimeout(() => {\n                this.playAlertSound();\n            }, 1000);\n            \n        } catch (e) {\n            console.log('Could not play enhanced alert sound:', e);\n        }\n    }\n\n    // Check for pending work completion on page load\n    checkForPendingWorkCompletion() {\n        if (!window.currentUser) return;\n\n        console.log('Checking for pending work completion on page load');\n\n        // ENHANCED: First, always check server state immediately for pending work completion\n        // This ensures users see notifications even on fresh page loads\n        this.performImmediateWorkCompletionCheck();\n\n        // Check localStorage for dismissed notifications that need progressive reminders\n        const dismissedData = localStorage.getItem('workCompletionDismissed');\n        if (dismissedData) {\n            try {\n                const parsed = JSON.parse(dismissedData);\n                const currentTime = Date.now();\n                \n                console.log('Found dismissed state in localStorage:', parsed);\n                \n                // If we're past the reminder start time, clear localStorage and start continuous reminders\n                if (currentTime >= parsed.reminderStartTime && parsed.username === window.currentUser) {\n                    console.log('Page refreshed after dismiss period - recovering continuous reminder state');\n                    localStorage.removeItem('workCompletionDismissed');\n                    \n                    // Fetch current user state to verify they still need to start rest\n                    fetch(`/get_user_state/${window.currentUser}`)\n                        .then(response => response.json())\n                        .then(data => {\n                            if (data.work_completed && data.pending_rest) {\n                                console.log('User still needs to start rest - starting continuous reminders');\n                                this.disableZoneButtons();\n                                \n                                const notificationData = {\n                                    username: parsed.username,\n                                    zone: parsed.zone,\n                                    rest_time: parsed.rest_time,\n                                    action: 'work_cycle_completed'\n                                };\n                                \n                                // Start continuous reminders immediately\n                                this.showProgressiveReminder(notificationData);\n                                this.progressiveReminderInterval = setInterval(() => {\n                                    this.showProgressiveReminder(notificationData);\n                                }, 10000);\n                            }\n                        });\n                    return;\n                }\n                \n                // If still within dismiss period, set up remaining timer for progressive reminder\n                if (currentTime < parsed.reminderStartTime && parsed.username === window.currentUser) {\n                    const remainingTime = parsed.reminderStartTime - currentTime;\n                    console.log(`Page refreshed during dismiss period - ${remainingTime}ms remaining until first reminder`);\n                    \n                    this.disableZoneButtons();\n                    \n                    this.dismissTimeout = setTimeout(() => {\n                        console.log('Recovered first progressive reminder after page refresh');\n                        this.showProgressiveReminder(parsed);\n                        \n                        this.progressiveReminderInterval = setInterval(() => {\n                            this.showProgressiveReminder(parsed);\n                        }, 10000);\n                        \n                    }, remainingTime);\n                    return;\n                }\n                \n                // If the dismiss period has expired and we're still here, clean up\n                console.log('Dismiss period expired, clearing localStorage');\n                localStorage.removeItem('workCompletionDismissed');\n            } catch (e) {\n                console.error('Error parsing localStorage data:', e);\n                localStorage.removeItem('workCompletionDismissed');\n            }\n        }\n\n        // Normal check for pending work completion\n        fetch(`/get_user_state/${window.currentUser}`)\n            .then(response => response.json())\n            .then(data => {\n                console.log('Checking for pending work completion:', data);\n                \n                if (data.work_completed && data.pending_rest) {\n                    console.log('Found pending work completion - showing modal');\n                    \n                    const restTime = this.getCorrectRestTime(data.zone);\n                    \n                    this.showWorkCompletionModal({\n                        title: 'Work Cycle Complete!',\n                        message: `Your work cycle has ended. Time to start rest cycle!`,\n                        username: window.currentUser,\n                        zone: data.zone,\n                        rest_duration: restTime\n                    });\n                }\n            })\n            .catch(error => {\n                console.error('Error checking for pending work completion:', error);\n            });\n    }\n}\n\n// Initialize the work completion modal system\nconst workModal = new WorkCompletionModal();\n\n// Listen for rest cycle completion to re-enable zone buttons\nif (typeof socket !== 'undefined') {\n    socket.on('user_update', function(data) {\n        if (data.user === window.currentUser && data.status === 'idle' && !data.work_completed && !data.pending_rest) {\n            // Rest cycle completed or user reset to idle\n            workModal.clearAllNotifications();\n        }\n    });\n}\n\n// ENHANCED: Check for pending work completion on page load with immediate response\ndocument.addEventListener('DOMContentLoaded', function() {\n    if (typeof window.currentUser !== 'undefined' && window.currentUser) {\n        // Immediate check without delay for faster response\n        workModal.checkForPendingWorkCompletion();\n        \n        // Also check again after a brief delay to ensure DOM is fully loaded\n        setTimeout(() => {\n            workModal.checkForPendingWorkCompletion();\n        }, 500);\n    }\n});\n\n// ENHANCED: Also check when page becomes visible (for tab switching scenarios)\ndocument.addEventListener('visibilitychange', function() {\n    if (!document.hidden && typeof window.currentUser !== 'undefined' && window.currentUser) {\n        console.log('Page became visible - checking for pending work completion');\n        workModal.checkForPendingWorkCompletion();\n    }\n});\n\n// Make workModal available globally\nwindow.workModal = workModal;","size_bytes":21998},"test_wbgt_zones.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nWBGT Zone Testing Script\nTests the zone transition from white -> green -> black -> white\nand verifies rest cycle time calculation based on most stringent zone\n\"\"\"\n\nimport time\nimport sqlite3\nfrom datetime import datetime, timedelta\nimport requests\n\ndef test_zone_transitions():\n    \"\"\"Test WBGT zone transitions and rest cycle calculations\"\"\"\n    \n    print(\"=== WBGT Zone Transition Test ===\")\n    print(\"Testing: white -> green -> black -> white\")\n    print(\"Expected: Rest cycle should be 30 minutes (based on black zone, not white)\")\n    print()\n    \n    # Connect to database to check internal state\n    try:\n        conn = sqlite3.connect('instance/wbgt_app.db')\n        cursor = conn.cursor()\n        \n        # Check if our test conduct exists\n        cursor.execute(\"SELECT id, pin, name FROM conduct WHERE name LIKE '%Test%' ORDER BY id DESC LIMIT 1\")\n        conduct_result = cursor.fetchone()\n        \n        if conduct_result:\n            conduct_id, pin, name = conduct_result\n            print(f\"Found test conduct: {name} (PIN: {pin}, ID: {conduct_id})\")\n            \n            # Check if we have test users\n            cursor.execute(\"SELECT id, name, role, most_stringent_zone FROM user WHERE conduct_id = ?\", (conduct_id,))\n            users = cursor.fetchall()\n            \n            if users:\n                print(f\"Found {len(users)} users in conduct:\")\n                for user_id, user_name, role, most_stringent in users:\n                    print(f\"  - {user_name} ({role}), most_stringent_zone: {most_stringent}\")\n                    \n                    # Test zone transitions for this user\n                    print(f\"\\n--- Testing zone transitions for {user_name} ---\")\n                    test_user_zone_transitions(user_id, cursor, conn)\n            else:\n                print(\"No users found in conduct\")\n        else:\n            print(\"No test conduct found\")\n            \n    except sqlite3.Error as e:\n        print(f\"Database error: {e}\")\n    finally:\n        if conn:\n            conn.close()\n\ndef test_user_zone_transitions(user_id, cursor, conn):\n    \"\"\"Test zone transitions for a specific user\"\"\"\n    \n    # Zone transition sequence: white -> green -> black -> white\n    zones = ['white', 'green', 'black', 'white']\n    \n    for i, zone in enumerate(zones):\n        print(f\"Step {i+1}: Setting zone to {zone}\")\n        \n        # Simulate setting zone via API call\n        try:\n            session = requests.Session()\n            zone_data = {\n                'user_id': user_id,\n                'target_user': 'Test User',  # Assuming this is our test user name\n                'zone': zone\n            }\n            response = session.post('http://localhost:5000/set_zone', data=zone_data)\n            print(f\"  API response: {response.status_code}\")\n            \n            # Wait a moment for database updates\n            time.sleep(1)\n            \n            # Check database state\n            cursor.execute(\"SELECT zone, most_stringent_zone, status, end_time FROM user WHERE id = ?\", (user_id,))\n            result = cursor.fetchone()\n            \n            if result:\n                current_zone, most_stringent, status, end_time = result\n                print(f\"  Current zone: {current_zone}\")\n                print(f\"  Most stringent zone: {most_stringent}\")\n                print(f\"  Status: {status}\")\n                print(f\"  End time: {end_time}\")\n                \n                # Calculate rest duration based on most stringent zone\n                rest_durations = {\n                    \"white\": 15,\n                    \"green\": 15, \n                    \"yellow\": 15,\n                    \"red\": 30,\n                    \"black\": 30,\n                    \"test\": 10,\n                    \"cut-off\": 30\n                }\n                expected_rest = rest_durations.get(most_stringent, 15)\n                print(f\"  Expected rest duration: {expected_rest} minutes (based on most stringent zone)\")\n            else:\n                print(f\"  Error: Could not retrieve user data\")\n                \n        except Exception as e:\n            print(f\"  Error setting zone: {e}\")\n        \n        print()\n\ndef analyze_most_stringent_logic():\n    \"\"\"Analyze the most stringent zone logic from source code\"\"\"\n    \n    print(\"=== Analysis of Most Stringent Zone Logic ===\")\n    \n    # Zone stringency hierarchy from the code\n    zone_stringency = {\n        \"white\": 0,\n        \"green\": 1, \n        \"yellow\": 2,\n        \"red\": 3,\n        \"black\": 4,\n        \"cut-off\": 5,\n        \"test\": 6\n    }\n    \n    # Rest durations from the code\n    wbgt_zones = {\n        \"white\": {\"work\": 60, \"rest\": 15},\n        \"green\": {\"work\": 45, \"rest\": 15},\n        \"yellow\": {\"work\": 30, \"rest\": 15},\n        \"red\": {\"work\": 30, \"rest\": 30},\n        \"black\": {\"work\": 15, \"rest\": 30},\n        \"test\": {\"work\": 7/60, \"rest\": 10},\n        \"cut-off\": {\"work\": 0, \"rest\": 30}\n    }\n    \n    print(\"Zone Stringency Hierarchy (higher number = more stringent):\")\n    for zone, level in sorted(zone_stringency.items(), key=lambda x: x[1]):\n        rest_time = wbgt_zones[zone][\"rest\"]\n        print(f\"  {level}: {zone.upper()} zone - {rest_time} minutes rest\")\n    \n    print(\"\\nTest Scenario: white -> green -> black -> white\")\n    zones_in_sequence = ['white', 'green', 'black', 'white']\n    stringency_levels = [zone_stringency[zone] for zone in zones_in_sequence]\n    most_stringent_level = max(stringency_levels)\n    most_stringent_zone = [zone for zone, level in zone_stringency.items() if level == most_stringent_level][0]\n    \n    print(f\"Most stringent zone in sequence: {most_stringent_zone.upper()} (level {most_stringent_level})\")\n    print(f\"Expected rest duration: {wbgt_zones[most_stringent_zone]['rest']} minutes\")\n    print(f\"Answer to your question: Rest cycle time should be {wbgt_zones[most_stringent_zone]['rest']} minutes\")\n    print(f\"This is based on {most_stringent_zone.upper()} zone, NOT white zone!\")\n\nif __name__ == \"__main__\":\n    # First, analyze the logic theoretically\n    analyze_most_stringent_logic()\n    print(\"\\n\" + \"=\"*60 + \"\\n\")\n    \n    # Then test with actual database\n    test_zone_transitions()","size_bytes":6206}}}