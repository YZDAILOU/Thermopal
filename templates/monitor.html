{% extends "layout.html" %}
{% block content %}
<div class="flex flex-col items-center p-4 max-w-6xl mx-auto">
  <h2 class="text-xl font-bold mb-4">WBGT Status Monitor</h2>
  <div class="text-sm text-gray-600 mb-4">Logged in as: {{ username }} ({{ role }})</div>

  <!-- Control Panel -->
  <div class="w-full mb-6 space-y-4">
    <!-- Cut-off Control -->
    <div class="bg-white p-4 rounded shadow">
      <h3 class="font-bold mb-2">System Control</h3>
      <div class="flex flex-col sm:flex-row gap-4">
        <button onclick="confirmCutOff()" class="flex-1 p-3 rounded text-white font-bold
          {% if system_status.cut_off %}
          bg-red-600 hover:bg-red-700
          {% else %}
          bg-green-600 hover:bg-green-700
          {% endif %}">
          {% if system_status.cut_off %}
          Deactivate Cut-Off Mode
          {% else %}
          Activate Cut-Off Mode
          {% endif %}
        </button>
        <button onclick="clearCommands()" class="flex-1 p-3 bg-yellow-500 hover:bg-yellow-600 text-white font-bold rounded">
          Clear Commands
        </button>
        <button onclick="resetLogs()" class="flex-1 p-3 bg-gray-500 hover:bg-gray-600 text-white font-bold rounded">
          Reset User Logs
        </button>
      </div>
      {% if system_status.cut_off_end_time %}
      <div class="mt-2 text-center text-red-600">
        Mandatory rest until: {{ system_status.cut_off_end_time }}
      </div>
      {% endif %}
    </div>

    <!-- WBGT Zone Control -->
    <div class="bg-white p-4 rounded shadow">
      <h3 class="font-bold mb-2">Modify WBGT Zones</h3>
      <div class="flex flex-col sm:flex-row gap-4">
        <div class="flex-1">
          {% for user_name, user_data in users.items() %}
            {% if user_data.get('role') == 'trainer' %}
            <div class="flex items-center p-2">
              <input type="checkbox" id="user_{{ user_name }}" value="{{ user_name }}" class="user-checkbox mr-2">
              <label for="user_{{ user_name }}">{{ user_name }}</label>
            </div>
            {% endif %}
          {% endfor %}
        </div>
        <div class="flex flex-col gap-2">
          {% for zone in zones %}
            {% if zone != 'cut-off' and zone != 'test' %}
            <button onclick="updateSelectedUsers('{{ zone }}')" 
              class="p-2 rounded text-sm font-semibold
              {% if zone == 'white' %}bg-white border border-gray-300 text-black
              {% elif zone == 'green' %}bg-green-400 text-white
              {% elif zone == 'yellow' %}bg-yellow-300 text-black
              {% elif zone == 'red' %}bg-red-400 text-white
              {% elif zone == 'black' %}bg-black text-white{% endif %}">
              {{ zone|title }}
            </button>
            {% endif %}
          {% endfor %}
        </div>
      </div>
    </div>
  </div>

  <!-- Users Table -->
  <div class="w-full overflow-x-auto bg-white shadow rounded-lg">
    <table class="min-w-full users-table">
      <thead class="bg-gray-50">
        <tr>
          <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">User</th>
          <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
          <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Zone</th>
          <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Start</th>
          <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">End</th>
          <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Time Left</th>
        </tr>
      </thead>
      <tbody class="divide-y divide-gray-200">
        {% for user_name, user_data in users.items() %}
          {% if user_data.get('role') == 'trainer' %}
            <tr data-user-id="{{ user_name }}">
              <td class="px-4 py-3 text-sm">
                <input type="checkbox" class="user-checkbox mr-2" value="{{ user_name }}">
                {{ user_name }}
                <button onclick="removeUser('{{ user_name }}')" class="ml-2 px-2 py-1 bg-red-500 hover:bg-red-600 text-white text-xs rounded">
                  Remove
                </button>
              </td>
              <td class="px-4 py-3 text-sm status-cell">{{ user_data.status|title }}</td>
              <td class="px-4 py-3 zone-cell">
                <span class="px-2 py-1 text-sm rounded zone-badge
                  {% if user_data.zone == 'white' %}bg-white border border-gray-300 text-black
                  {% elif user_data.zone == 'green' %}bg-green-400 text-white
                  {% elif user_data.zone == 'yellow' %}bg-yellow-300 text-black
                  {% elif user_data.zone == 'red' %}bg-red-400 text-white
                  {% elif user_data.zone == 'black' %}bg-black text-white
                  {% elif user_data.zone == 'cut-off' %}bg-red-600 text-white{% endif %}">
                  {{ user_data.zone|title if user_data.zone else '-' }}
                </span>
              </td>
              <td class="px-4 py-3 text-sm start-time-cell">{{ user_data.get('start_time', '-') }}</td>
              <td class="px-4 py-3 text-sm end-time-cell">{{ user_data.get('end_time', '-') }}</td>
              <td class="px-4 py-3 text-sm time-left-cell font-mono font-bold">-</td>
            </tr>
          {% endif %}
        {% endfor %}
      </tbody>
    </table>
  </div>

  <!-- History Log -->
  <div class="mt-8 w-full bg-white shadow rounded-lg overflow-hidden">
    <h3 class="px-4 py-3 bg-gray-50 font-bold">Activity History</h3>
    <div class="overflow-x-auto max-h-96">
      <table class="min-w-full" id="history-table">
        <thead class="bg-gray-50 sticky top-0">
          <tr>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Timestamp</th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">User</th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Action</th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Zone</th>
            <th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Details</th>
          </tr>
        </thead>
        <tbody class="divide-y divide-gray-200">
          {% for entry in history %}
          <tr>
            <td class="px-4 py-3 text-sm">{{ entry.timestamp }}</td>
            <td class="px-4 py-3 text-sm">{{ entry.username }}</td>
            <td class="px-4 py-3 text-sm">{{ entry.action.replace('_', ' ') }}</td>
            <td class="px-4 py-3 text-sm">{{ entry.zone or '-' }}</td>
            <td class="px-4 py-3 text-sm">{{ entry.details or '' }}</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  </div>
</div>

<script>
// Global variables
const currentUser = "{{ username }}";
const conductId = {{ conduct_id }};
const userRole = "{{ role }}";

// Initialize socket connection
const socket = io();

// Join conduct room for real-time updates
socket.emit('join_conduct', { conduct_id: conductId });

// Server time synchronization
let serverTimeOffset = 0;

function getServerSynchronizedTime() {
    return new Date(Date.now() + serverTimeOffset);
}

async function synchronizeWithServerTime() {
    try {
        const response = await fetch('/get_server_time');
        const data = await response.json();
        const serverTimestamp = data.timestamp * 1000;
        const localTimestamp = Date.now();
        serverTimeOffset = serverTimestamp - localTimestamp;
        console.log(`Server time sync: offset = ${serverTimeOffset}ms`);
    } catch (error) {
        console.error('Failed to sync with server time:', error);
        serverTimeOffset = 0;
    }
}

function calculateTimeLeft(endTime) {
    if (!endTime || endTime === '-') return '-';

    // Use server-synchronized time for accuracy (same as trainer interface)
    const now = getServerSynchronizedTime();
    const end = new Date();
    const [hours, minutes, seconds] = endTime.split(':');
    end.setHours(hours, minutes, seconds || 0, 0);

    // Handle midnight rollover: if end time is significantly earlier than current time,
    // assume it's for the next day
    const currentHour = now.getHours();
    const endHour = parseInt(hours);
    
    if (endHour < currentHour && (currentHour - endHour) > 12) {
        end.setDate(end.getDate() + 1);
        console.log(`Monitor: Midnight rollover detected for end time ${endTime}`);
    }

    const timeLeftMs = Math.max(0, end - now);
    const timeLeftSecs = Math.ceil(timeLeftMs / 1000); // Match trainer interface: Round UP for consistency

    if (timeLeftSecs <= 0) return '0:00';

    const minsLeft = Math.floor(timeLeftSecs / 60);
    const secsLeft = timeLeftSecs % 60;

    return `${minsLeft}:${String(secsLeft).padStart(2, '0')}`;
}

// Real-time countdown timers
let userTimers = {};

function startUserTimer(userId, endTime) {
    if (userTimers[userId]) {
        clearInterval(userTimers[userId]);
    }

    if (!endTime || endTime === '-') {
        const timeCell = document.querySelector(`tr[data-user-id="${userId}"] .time-left-cell`);
        if (timeCell) timeCell.textContent = '-';
        return;
    }

    updateUserTimeDisplay(userId, endTime);

    userTimers[userId] = setInterval(() => {
        updateUserTimeDisplay(userId, endTime);
    }, 1000);
}

function updateUserTimeDisplay(userId, endTime) {
    const timeCell = document.querySelector(`tr[data-user-id="${userId}"] .time-left-cell`);
    if (!timeCell) return;

    const timeLeft = calculateTimeLeft(endTime);
    timeCell.textContent = timeLeft;

    if (timeLeft === '0:00' || timeLeft === '-') {
        clearInterval(userTimers[userId]);
        delete userTimers[userId];
    }
}

// Control functions
function confirmCutOff() {
    const isActive = {{ 'true' if system_status.cut_off else 'false' }};
    const action = isActive ? 'deactivate' : 'activate';

    if (confirm(`Are you sure you want to ${action} cut-off mode?`)) {
        toggleCutOff();
    }
}

function toggleCutOff() {
    const userId = {{ user_id }};

    fetch('/toggle_cut_off', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: new URLSearchParams({
            'user_id': userId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Cut-off toggled successfully');
            // Don't reload - let Socket.IO handle the update
        } else {
            alert(data.error || 'Failed to toggle cut-off mode');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Network error occurred');
    });
}

function clearCommands() {
    if (confirm('Are you sure you want to clear all commands and reset all trainer interfaces?')) {
        const userId = {{ user_id }};

        fetch('/clear_commands', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'user_id': userId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log('Commands cleared and interfaces reset successfully');
                // Don't reload - let Socket.IO handle the updates
                alert('All commands cleared and trainer interfaces reset successfully!');
            } else {
                alert(data.error || 'Failed to clear commands and reset interfaces');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Network error occurred');
        });
    }
}

function resetLogs() {
    if (confirm('Are you sure you want to reset all user logs?')) {
        // Implementation for resetting logs
        location.reload();
    }
}

function updateSelectedUsers(zone) {
    const checkboxes = document.querySelectorAll('.user-checkbox:checked');
    const selectedUsers = Array.from(checkboxes).map(cb => cb.value);

    if (selectedUsers.length === 0) {
        alert('Please select at least one user');
        return;
    }

    const userId = {{ user_id }};

    selectedUsers.forEach(targetUser => {
        fetch('/set_zone', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'user_id': userId,
                'target_user': targetUser,
                'zone': zone
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log(`Updated ${targetUser} to ${zone}`);
                // Don't reload - let Socket.IO handle the update
            } else {
                alert(`Failed to update ${targetUser}: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
        });
    });

    // Clear selections
    checkboxes.forEach(cb => cb.checked = false);
}

function removeUser(username) {
    if (confirm(`Are you sure you want to remove ${username} from this conduct?`)) {
        const userId = {{ user_id }};

        fetch('/remove_user', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'user_id': userId,
                'target_user': username
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log(`Removed ${username} from conduct`);
                // Remove the user row from the table
                const userRow = document.querySelector(`tr[data-user-id="${username}"]`);
                if (userRow) {
                    userRow.remove();
                }
                // Remove from zone control checkboxes
                const zoneCheckbox = document.querySelector(`#user_${username}`);
                if (zoneCheckbox && zoneCheckbox.parentElement) {
                    zoneCheckbox.parentElement.remove();
                }
                alert(`${username} has been removed from the conduct`);
            } else {
                alert(`Failed to remove ${username}: ${data.error}`);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Network error occurred');
        });
    }
}

// Helper function to create a new user row
function createUserRow(userData) {
    const row = document.createElement('tr');
    row.setAttribute('data-user-id', userData.user);

    row.innerHTML = `
        <td class="px-4 py-3 text-sm">
            <input type="checkbox" class="user-checkbox mr-2" value="${userData.user}">
            ${userData.user}
            <button onclick="removeUser('${userData.user}')" class="ml-2 px-2 py-1 bg-red-500 hover:bg-red-600 text-white text-xs rounded">
              Remove
            </button>
        </td>
        <td class="px-4 py-3 text-sm status-cell">${userData.status.charAt(0).toUpperCase() + userData.status.slice(1)}</td>
        <td class="px-4 py-3 zone-cell">
            <span class="px-2 py-1 text-sm rounded zone-badge bg-white border border-gray-300 text-black">
                ${userData.zone ? userData.zone.charAt(0).toUpperCase() + userData.zone.slice(1) : '-'}
            </span>
        </td>
        <td class="px-4 py-3 text-sm start-time-cell">${userData.start_time || '-'}</td>
        <td class="px-4 py-3 text-sm end-time-cell">${userData.end_time || '-'}</td>
        <td class="px-4 py-3 text-sm time-left-cell font-mono font-bold">-</td>
    `;

    return row;
}

// Helper function to add user to zone control checkboxes
function addUserToZoneControl(userName) {
    // Target the WBGT Zone Control section specifically (second .bg-white.p-4.rounded.shadow div)
    const zoneControlSections = document.querySelectorAll('.bg-white.p-4.rounded.shadow');
    const zoneControlSection = zoneControlSections[1]; // Second section is WBGT Zone Control
    const zoneControlDiv = zoneControlSection ? zoneControlSection.querySelector('.flex-1') : null;

    if (zoneControlDiv) {
        const userDiv = document.createElement('div');
        userDiv.className = 'flex items-center p-2';
        userDiv.innerHTML = `
            <input type="checkbox" id="user_${userName}" value="${userName}" class="user-checkbox mr-2">
            <label for="user_${userName}">${userName}</label>
        `;
        zoneControlDiv.appendChild(userDiv);
    }
}

// Initialize timers for all users
document.addEventListener('DOMContentLoaded', async function() {
    await synchronizeWithServerTime();

    {% for user_name, user_data in users.items() %}
      {% if user_data.get('role') == 'trainer' and user_data.get('end_time') %}
        startUserTimer('{{ user_name }}', '{{ user_data.end_time }}');
      {% endif %}
    {% endfor %}
});

// Socket event handlers
socket.on('user_update', function(data) {
    console.log('Received user update:', data);

    // Update user display
    let userRow = document.querySelector(`tr[data-user-id="${data.user}"]`);

    // If user row doesn't exist, create it (new user joined)
    if (!userRow && data.role === 'trainer') {
        console.log('Creating new row for user:', data.user);
        const tbody = document.querySelector('.users-table tbody');
        if (tbody) {
            userRow = createUserRow(data);
            tbody.appendChild(userRow);

            // Also add to zone control checkboxes
            addUserToZoneControl(data.user);
        }
    }

    if (userRow) {
        userRow.querySelector('.status-cell').textContent = data.status.charAt(0).toUpperCase() + data.status.slice(1);
        userRow.querySelector('.start-time-cell').textContent = data.start_time || '-';
        userRow.querySelector('.end-time-cell').textContent = data.end_time || '-';

        // Update zone badge
        const zoneBadge = userRow.querySelector('.zone-badge');
        if (zoneBadge) {
            zoneBadge.textContent = data.zone ? data.zone.charAt(0).toUpperCase() + data.zone.slice(1) : '-';

            // Update zone badge styling
            zoneBadge.className = 'px-2 py-1 text-sm rounded zone-badge';
            if (data.zone === 'white') {
                zoneBadge.className += ' bg-white border border-gray-300 text-black';
            } else if (data.zone === 'green') {
                zoneBadge.className += ' bg-green-400 text-white';
            } else if (data.zone === 'yellow') {
                zoneBadge.className += ' bg-yellow-300 text-black';
            } else if (data.zone === 'red') {
                zoneBadge.className += ' bg-red-400 text-white';
            } else if (data.zone === 'black') {
                zoneBadge.className += ' bg-black text-white';
            }
        }

        // Start/stop timer
        if (data.end_time && data.end_time !== '-') {
            startUserTimer(data.user, data.end_time);
        } else {
            if (userTimers[data.user]) {
                clearInterval(userTimers[data.user]);
                delete userTimers[data.user];
            }
            userRow.querySelector('.time-left-cell').textContent = '-';
        }
    }
});

socket.on('system_status_update', function(data) {
    console.log('Received system status update:', data);
    updateSystemStatusDisplay(data);
});

function updateSystemStatusDisplay(systemStatus) {
    // Update cut-off button
    const cutOffButton = document.querySelector('button[onclick="confirmCutOff()"]');
    if (cutOffButton) {
        if (systemStatus.cut_off) {
            cutOffButton.textContent = 'Deactivate Cut-Off Mode';
            cutOffButton.className = 'flex-1 p-3 rounded text-white font-bold bg-red-600 hover:bg-red-700';
        } else {
            cutOffButton.textContent = 'Activate Cut-Off Mode';
            cutOffButton.className = 'flex-1 p-3 rounded text-white font-bold bg-green-600 hover:bg-green-700';
        }
    }

    // Update mandatory rest message
    const controlPanel = document.querySelector('.bg-white.p-4.rounded.shadow');
    const existingMessage = controlPanel.querySelector('.mt-2.text-center.text-red-600');

    if (systemStatus.cut_off_end_time) {
        if (!existingMessage) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'mt-2 text-center text-red-600';
            messageDiv.textContent = `Mandatory rest until: ${systemStatus.cut_off_end_time}`;
            controlPanel.appendChild(messageDiv);
        } else {
            existingMessage.textContent = `Mandatory rest until: ${systemStatus.cut_off_end_time}`;
        }
    } else if (existingMessage) {
        existingMessage.remove();
    }
}

socket.on('history_update', function(data) {
    console.log('History update received:', data);
    updateActivityHistoryTable(data.history || []);
});

function updateActivityHistoryTable(historyData) {
    const tbody = document.querySelector('#history-table tbody');
    if (!tbody) return;

    tbody.innerHTML = historyData.map(entry => `
        <tr>
            <td class="px-4 py-3 text-sm">${entry.timestamp}</td>
            <td class="px-4 py-3 text-sm">${entry.username}</td>
            <td class="px-4 py-3 text-sm">${entry.action.replace('_', ' ')}</td>
            <td class="px-4 py-3 text-sm">${entry.zone || '-'}</td>
            <td class="px-4 py-3 text-sm">${entry.details || ''}</td>
        </tr>
    `).join('');
    
    console.log(`Activity history updated with ${historyData.length} entries`);
}

socket.on('force_history_refresh', function(data) {
    console.log('Force history refresh received:', data);
    // Manually fetch updated history to ensure we have the latest data
    fetch(`/get_conduct_history/{{ conduct_id }}`)
        .then(response => response.json())
        .then(historyData => {
            updateActivityHistoryTable(historyData.history || []);
        })
        .catch(error => console.error('Error fetching history:', error));
});

socket.on('connect', function() {
    console.log('Socket connected');
    // Rejoin conduct room on reconnect
    socket.emit('join_conduct', { conduct_id: conductId });
});

socket.on('disconnect', function() {
    console.log('Socket disconnected');
});

socket.on('user_removed', function(data) {
    console.log('User removed:', data);

    // Remove user row from table
    const userRow = document.querySelector(`tr[data-user-id="${data.user}"]`);
    if (userRow) {
        userRow.remove();
    }

    // Remove from zone control checkboxes
    const zoneCheckbox = document.querySelector(`#user_${data.user}`);
    if (zoneCheckbox && zoneCheckbox.parentElement) {
        zoneCheckbox.parentElement.remove();
    }

    // Clear any active timers for this user
    if (userTimers[data.user]) {
        clearInterval(userTimers[data.user]);
        delete userTimers[data.user];
    }
});
</script>
{% endblock %}